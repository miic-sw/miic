<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>miic.core.miic_utils &mdash; MIIC 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="MIIC 1.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MIIC 1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for miic.core.miic_utils</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@author:</span>
<span class="sd">Eraldo Pomponi</span>

<span class="sd">@copyright:</span>
<span class="sd">The MIIC Development Team (eraldo.pomponi@uni-leipzig.de)</span>

<span class="sd">@license:</span>
<span class="sd">GNU Lesser General Public License, Version 3</span>
<span class="sd">(http://www.gnu.org/copyleft/lesser.html)</span>

<span class="sd">Created on Oct 5, 2011</span>

<span class="sd">Changes:</span>
<span class="sd">- convert npts from type used in obspy future.types.newint.newint</span>
<span class="sd">  back to long as new types stumble savemat  (21/07/2015 F Tilmann)</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c"># Main imports</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="kn">as</span> <span class="nn">sio</span>
<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">loadmat</span><span class="p">,</span> <span class="n">savemat</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">cPickle</span> <span class="kn">import</span> <span class="n">Pickler</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">importlib</span>


<span class="c"># Pandas import</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Panel</span><span class="p">,</span> <span class="n">Series</span>
<span class="kn">from</span> <span class="nn">pandas.io.parsers</span> <span class="kn">import</span> <span class="n">read_table</span>

<span class="c"># ETS imports</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">BC_UI</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="kn">from</span> <span class="nn">traits.api</span> <span class="kn">import</span> <span class="n">HasTraits</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> \
        <span class="n">Str</span><span class="p">,</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">Directory</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span> <span class="n">Float</span>
    <span class="kn">from</span> <span class="nn">traitsui.api</span> <span class="kn">import</span> <span class="n">View</span><span class="p">,</span> <span class="n">Item</span><span class="p">,</span> <span class="n">VGroup</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">BC_UI</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">pass</span>
    
<span class="c"># Obspy imports</span>
<span class="kn">from</span> <span class="nn">obspy.core</span> <span class="kn">import</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">Trace</span><span class="p">,</span> <span class="n">UTCDateTime</span>


<span class="c">##############################################################################</span>
<span class="c"># Exceptions                                                                 #</span>
<span class="c">##############################################################################</span>


<span class="k">class</span> <span class="nc">InputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception for Input errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="c">##############################################################################</span>
<span class="c"># Utility                                                                    #</span>
<span class="c">##############################################################################</span>


<span class="k">def</span> <span class="nf">create_rnd_array</span><span class="p">(</span><span class="n">nSignal</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nSample</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a random normal 2D ndarray.</span>

<span class="sd">    This function creates a 2D random normal array where the number of rows</span>
<span class="sd">    are equal to ``nSignal`` and the number of columns are equal</span>
<span class="sd">    to ``nSamples``.</span>

<span class="sd">    :type nSignal: int</span>
<span class="sd">    :param nSignal: Number of random realizations (rows).</span>
<span class="sd">    :type nSample: int</span>
<span class="sd">    :param nSamples: Number of samples of each realization (col)</span>

<span class="sd">    :rtype: 2D :class:`~numpy.ndarray`</span>
<span class="sd">    :return: **rnd_array**: random normal ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rnd_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">nSignal</span><span class="p">,</span> <span class="n">nSample</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rnd_array</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_create_rnd_array_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">nSignal</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nSample</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
    
        <span class="n">traits_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;nSignal&#39;</span><span class="p">),</span>
                           <span class="n">Item</span><span class="p">(</span><span class="s">&#39;nSample&#39;</span><span class="p">))</span>
                           

<span class="k">def</span> <span class="nf">create_range_array</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nSamples</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a 1D ndarray using range.</span>

<span class="sd">    This function creates an 1D array that has ``nSamples`` elements in the</span>
<span class="sd">    range from ``low`` to ``high``.</span>

<span class="sd">    :type low: int</span>
<span class="sd">    :param low: Range low boundary</span>
<span class="sd">    :type high: int</span>
<span class="sd">    :param high: Range high boundary</span>
<span class="sd">    :type nSamples: int</span>
<span class="sd">    :param nSamples: Number of samples</span>

<span class="sd">    :rtype: 1D :class:`~numpy.ndarray`</span>
<span class="sd">    :return: **range_array**: 1d ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span> <span class="o">==</span> <span class="n">nSamples</span><span class="p">):</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">nSamples</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ar</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_create_range_array_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">low</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nSamples</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
    
        <span class="n">traits_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;low&#39;</span><span class="p">),</span>
                           <span class="n">Item</span><span class="p">(</span><span class="s">&#39;high&#39;</span><span class="p">),</span>
                           <span class="n">Item</span><span class="p">(</span><span class="s">&#39;nSamples&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="dict_sel"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.dict_sel.html#miic.core.miic_utils.dict_sel">[docs]</a><span class="k">def</span> <span class="nf">dict_sel</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Dictionary element selection.</span>

<span class="sd">    Return the value associated with a specified ``key`` in the input</span>
<span class="sd">    dictionary ``d``.</span>

<span class="sd">    :type d: dictionary</span>
<span class="sd">    :param d: Dictionary</span>
<span class="sd">    :type key: any</span>
<span class="sd">    :param key: Selected key</span>

<span class="sd">    :rtype: any</span>
<span class="sd">    :return: **d[key]**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;key not found&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_dict_sel_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">key</span> <span class="o">=</span> <span class="n">Str</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;key&#39;</span><span class="p">))</span>
    

<span class="k">def</span> <span class="nf">add_prefix</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Add a prefix to a read-only string.</span>

<span class="sd">    :type name; string</span>
<span class="sd">    :param name: Read only string</span>
<span class="sd">    :type prefix: string</span>
<span class="sd">    :param prefix: Prefix to be added.</span>

<span class="sd">    :rtype: string</span>
<span class="sd">    :return: **comb_str**: Concatenated string prefix + name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">name</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_add_prefix_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">Str</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">Str</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s">&#39;readonly&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;prefix&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">merge_str</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Merge two strings.</span>

<span class="sd">    :type str1: string</span>
<span class="sd">    :param str1: First string</span>
<span class="sd">    :type str2: string</span>
<span class="sd">    :param str2: Second string</span>

<span class="sd">    :rtype: string</span>
<span class="sd">    :return: **comb_str**: str1 + str2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_merge_str_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">str1</span> <span class="o">=</span> <span class="n">Str</span>
        <span class="n">str2</span> <span class="o">=</span> <span class="n">Str</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;str1&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;str2&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="dir_read"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.dir_read.html#miic.core.miic_utils.dir_read">[docs]</a><span class="k">def</span> <span class="nf">dir_read</span><span class="p">(</span><span class="n">base_dir</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.webnet&#39;</span><span class="p">,</span> <span class="n">sort_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a list of files in a dir tree which name match a def pattern.</span>

<span class="sd">    :type base_dir: directory</span>
<span class="sd">    :param base_dir: Directories tree root</span>
<span class="sd">    :type pattern: string</span>
<span class="sd">    :param pattern: Patter to look for (e.g. *.mseed, */*/.mseed etc)</span>
<span class="sd">    :type sort_flag: bool</span>
<span class="sd">    :param sort_flag: If the result should be sorted or not</span>

<span class="sd">    :rtype: list of string</span>
<span class="sd">    :return: **files_list**: List of all files matching the ``pattern``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">glob</span>

    <span class="k">if</span> <span class="n">sort_flag</span><span class="p">:</span>
        <span class="n">files_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">files_list</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">files_list</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_dir_read_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">base_dir</span> <span class="o">=</span> <span class="n">Directory</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&#39;*.webnet&#39;</span><span class="p">)</span>
        <span class="n">sort_flag</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># preview = Button(&#39;Preview&#39;)</span>
        <span class="c"># file_list_preview = List(File)</span>
        <span class="n">files_list</span> <span class="o">=</span> <span class="n">List</span>
        <span class="n">_file_list_preview</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">File</span><span class="p">)</span>
        <span class="n">_num_files</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;base_dir&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;pattern&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;sort_flag&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;sorted&#39;</span><span class="p">),</span>
                          <span class="c"># Item(&#39;preview&#39;),</span>
                          <span class="c"># HGroup(Item(&#39;file_list_preview&#39;, style=&#39;readonly&#39;),</span>
                          <span class="c">#       Item(&#39;num_files&#39;, style=&#39;readonly&#39;)),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;_num_files&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s">&#39;readonly&#39;</span><span class="p">,</span> \
                               <span class="n">label</span><span class="o">=</span><span class="s">&#39;Num selec. files&#39;</span><span class="p">),</span>
                          <span class="n">resizable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_list</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.webnet&#39;</span><span class="p">,</span> \
                     <span class="n">sort_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">file_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_file_list_prev</span> <span class="o">=</span> <span class="n">file_list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span> <span class="o">=</span> <span class="n">base_dir</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span> <span class="o">=</span> <span class="n">sort_flag</span>
    
        <span class="k">def</span> <span class="nf">_base_dir_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_file_list_preview</span> <span class="o">=</span> <span class="n">dir_read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> \
                                               <span class="bp">self</span><span class="o">.</span><span class="n">sort_flag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_list_preview</span><span class="p">)</span>
    
        <span class="k">def</span> <span class="nf">_pattern_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_file_list_preview</span> <span class="o">=</span> <span class="n">dir_read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> \
                                               <span class="bp">self</span><span class="o">.</span><span class="n">sort_flag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_list_preview</span><span class="p">)</span>


<span class="n">zerotime</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">1971</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="create_path"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.create_path.html#miic.core.miic_utils.create_path">[docs]</a><span class="k">def</span> <span class="nf">create_path</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a given path with all preceeding parts.</span>

<span class="sd">    Provided there is write access the function will creates</span>
<span class="sd">    all levels of the given path.</span>

<span class="sd">    :type directory: string</span>
<span class="sd">    :param directory: path of the directory to be created</span>

<span class="sd">    :rtype: int</span>
<span class="sd">    :return: 0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span> <span class="p">:</span>
        <span class="c"># Use try in case another parallel process has made it in that time</span>
        <span class="k">try</span> <span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">17</span> <span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">directory</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> exists but is not a directory&quot;</span> <span class="o">%</span> <span class="n">subpath</span>
    <span class="k">return</span> <span class="mi">0</span>


</div>
<div class="viewcode-block" id="archive_code"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.archive_code.html#miic.core.miic_utils.archive_code">[docs]</a><span class="k">def</span> <span class="nf">archive_code</span><span class="p">(</span><span class="n">scriptname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read parameters and archive code</span>

<span class="sd">    This is a convenience function that helps to track processing routines and</span>
<span class="sd">    parameter setting. Tracking is not done by propagating meta information.</span>
<span class="sd">    It just archives parameter files and processing scripts. The functions</span>
<span class="sd">    assumes that parameters are stored in a pythen file of the</span>
<span class="sd">    same name as the script that calls this function extended with `_par`.</span>
<span class="sd">    These parameters are read and returned as a module (e.g. `par`). This</span>
<span class="sd">    means that a parameter `parameter` set in the parameter file is accessible</span>
<span class="sd">    `par.parameter`. One parameter is required to be present in the parameter</span>
<span class="sd">    file: `res_dir`. This directory is created and within it a folder</span>
<span class="sd">    `code_dir` to which the script and the paremater files are copied and extended</span>
<span class="sd">    by a time string.</span>

<span class="sd">    :type scriptname: string</span>
<span class="sd">    :param scriptname: name of the executed script that is to be archived</span>

<span class="sd">    :rtype: module</span>
<span class="sd">    :return: module with the parameters for the script</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># time string</span>
    <span class="n">tim</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&#39;%Y%m</span><span class="si">%d</span><span class="s">_%H%M%S&#39;</span><span class="p">)</span>
    <span class="c"># name of paramter file according to above convention</span>
    <span class="n">parname</span> <span class="o">=</span> <span class="n">scriptname</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;_par&#39;</span>
    <span class="c"># import parameters</span>
    <span class="n">par</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">parname</span><span class="p">)</span>
    <span class="c"># create directory to archive scripts</span>
    <span class="n">code_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">res_dir</span><span class="p">,</span><span class="s">&#39;code_dir&#39;</span><span class="p">)</span>
    <span class="n">create_path</span><span class="p">(</span><span class="n">code_dir</span><span class="p">)</span>
    <span class="c"># copy files</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">scriptname</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">code_dir</span><span class="p">,</span><span class="n">scriptname</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">tim</span><span class="o">+</span><span class="s">&#39;.py&#39;</span><span class="p">))</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">parname</span><span class="o">+</span><span class="s">&#39;.py&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">code_dir</span><span class="p">,</span><span class="n">parname</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">+</span><span class="n">tim</span><span class="o">+</span><span class="s">&#39;.py&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">par</span>

</div>
<div class="viewcode-block" id="ndarray_to_mat"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.ndarray_to_mat.html#miic.core.miic_utils.ndarray_to_mat">[docs]</a><span class="k">def</span> <span class="nf">ndarray_to_mat</span><span class="p">(</span><span class="n">nd_array</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&quot;canvas_mat.mat&quot;</span><span class="p">,</span> \
                   <span class="n">mat_var_name</span><span class="o">=</span><span class="s">&#39;corr_data&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Save an ndarray to a Matlab file.</span>

<span class="sd">    :type nd_array: :class:`~numpy.ndarray`</span>
<span class="sd">    :param nd_array: Array to be saved</span>
<span class="sd">    :type base_dir: directory</span>
<span class="sd">    :param base_dir: Directory where to save the file (i.e. the current one if</span>
<span class="sd">        not specified)</span>
<span class="sd">    :type filename: string</span>
<span class="sd">    :param filename: File name</span>
<span class="sd">    :type mat_var_name: string</span>
<span class="sd">    :param mat_var_name: The name of the matlab variable that will store the</span>
<span class="sd">        ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">):</span>
        <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>

    <span class="n">sio</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="p">{</span><span class="n">mat_var_name</span><span class="p">:</span> <span class="n">nd_array</span><span class="p">})</span>
    <span class="k">return</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_ndarray_to_mat_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">base_dir</span> <span class="o">=</span> <span class="n">Directory</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">Str</span>
        <span class="n">mat_var_name</span> <span class="o">=</span> <span class="n">Str</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;base_dir&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;mat_var_name&#39;</span><span class="p">))</span>
    

<div class="viewcode-block" id="mat_to_ndarray"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.mat_to_ndarray.html#miic.core.miic_utils.mat_to_ndarray">[docs]</a><span class="k">def</span> <span class="nf">mat_to_ndarray</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load a Matlab file into a dictionary.</span>

<span class="sd">    Keys of this dictionary are the names of the variables stored in the file.</span>

<span class="sd">    :type filename: full path filename</span>
<span class="sd">    :param filename: The name of the file to be loaded</span>

<span class="sd">    :rtype load_var: dictionary</span>
<span class="sd">    :return: **load_var**: Returned dictionary of the</span>
<span class="sd">        form { &#39;var_name&#39; : var_value}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">load_var</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="n">sio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mdict</span><span class="o">=</span><span class="n">load_var</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;file doesn&#39;t exist&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
        <span class="c"># Flatten the returned dictionary</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">load_var</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">load_var</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">flat_var</span> <span class="o">=</span> <span class="n">flatten_recarray</span><span class="p">(</span><span class="n">load_var</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="n">load_var</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">flat_var</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">load_var</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_mat_to_ndarray_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">filename</span> <span class="o">=</span> <span class="n">File</span>
        <span class="n">flatten</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;flatten&#39;</span><span class="p">))</span>
    

<div class="viewcode-block" id="convert_to_matlab"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.convert_to_matlab.html#miic.core.miic_utils.convert_to_matlab">[docs]</a><span class="k">def</span> <span class="nf">convert_to_matlab</span><span class="p">(</span><span class="n">st</span><span class="p">,</span>
                      <span class="n">base_name</span><span class="p">,</span>
                      <span class="n">base_dir</span><span class="p">,</span>
                      <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span>
                      <span class="n">seconds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                      <span class="n">is_corr</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Save an ObsPy Stream to a series of Matlab files.</span>

<span class="sd">    Each ``Trace`` contained in the ``Stream`` object will be stored in a</span>
<span class="sd">    different file which name is formatted as</span>
<span class="sd">    ``&lt;timestamp&gt;_&#39;base_name&#39;_&lt;trace_seed_id_no_dash&gt;_&#39;suffix&#39;_.mat``.</span>
<span class="sd">    Both &lt;timestamp&gt; and &lt;trace_seed_id_no_dash&gt; are generated directly</span>
<span class="sd">    reading trace meta-information so they are not accessible.</span>
<span class="sd">    If ``base_name == None or base_name == &#39;&#39;`` it is substituted with the</span>
<span class="sd">    string ``trace``.</span>
<span class="sd">    if ``suffix == None or suffix ==&#39;&#39;`` it simply omitted keeping just one</span>
<span class="sd">    underscore to close the filename.</span>
<span class="sd">    This way to compose the filename is consistent with what expected by</span>
<span class="sd">    functions like :class:`~miic.core.macro.recombine_corr_data` that are</span>
<span class="sd">    supposed to read back the data from them.</span>
<span class="sd">    In case the parameter ``second`` is passed and different from 0 just</span>
<span class="sd">    ``second`` seconds will be saved in the Matlab file so that, for each</span>
<span class="sd">    ``Trace`` ``tr``, what is taken is ``tr(tr.stats.starttime,</span>
<span class="sd">    tr.stats.starttime + seconds).</span>
<span class="sd">    If the ``is_corr`` flag is `True``, the time interval is doubled and is</span>
<span class="sd">    symmetric respect to the default &quot;zero-timelag&quot; of</span>
<span class="sd">    UTCDateTime(1971, 1, 1, 0, 0, 0).</span>

<span class="sd">    &gt;&gt;&gt;ref = UTCDateTime(1971, 1, 1, 0, 0, 0)</span>
<span class="sd">    &gt;&gt;&gt;tr = tr.slice(ref-seconds,ref+seconds)</span>

<span class="sd">    :type st: :class:`~obspy.core.stream.Stream`</span>
<span class="sd">    :param st: ObsPy ``Stream`` object to be saved</span>
<span class="sd">    :type base_name: string</span>
<span class="sd">    :param base_name: Common &quot;root&quot; for every generated filename.</span>
<span class="sd">        It must not include underscores.</span>
<span class="sd">    :type base_dir: directory</span>
<span class="sd">    :param base_dir: Path where to save the files</span>
<span class="sd">    :type suffix: string</span>
<span class="sd">    :param suffix: Optional suffix for the filename</span>
<span class="sd">    :type seconds: int (Optional)</span>
<span class="sd">    :param seconds: How many seconds to retain of the original trace</span>
<span class="sd">    :type is_corr: bool (Optional)</span>
<span class="sd">    :param is_corr: If True the seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">Stream</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;st must be an obspy Stream object.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">):</span>
        <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">base_name</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">base_name</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
        <span class="n">base_name</span> <span class="o">=</span> <span class="s">&#39;trace&#39;</span>

    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
        <span class="c"># It is less efficient to do that trace by trace but we do not know</span>
        <span class="c"># if all of them have the same starting time or not.</span>
        <span class="k">if</span> <span class="n">seconds</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_corr</span><span class="p">:</span>
                <span class="n">tr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                              <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">+</span> <span class="n">seconds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_start</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">1971</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">seconds</span>
                <span class="n">t_stop</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">1971</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">seconds</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_stop</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">base_name</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">tr</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">suffix</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">suffix</span>

        <span class="c"># filename += &#39;_&#39;</span>

        <span class="n">mat_struct</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="s">&#39;stats_tr1&#39;</span><span class="p">):</span>

            <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>

            <span class="n">_tr1dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;network&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                        <span class="s">&#39;station&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">station</span><span class="p">,</span>
                        <span class="s">&#39;location&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                        <span class="s">&#39;channel&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
                        <span class="s">&#39;sampling_rate&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                        <span class="s">&#39;starttime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                        <span class="s">&#39;endtime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span>
                        <span class="s">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">long</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">npts</span><span class="p">)}</span>
            <span class="k">if</span> <span class="s">&#39;sac&#39;</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="p">:</span>
                <span class="n">_tr1dict</span><span class="p">[</span><span class="s">&#39;stla&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stla</span>
                <span class="n">_tr1dict</span><span class="p">[</span><span class="s">&#39;stlo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stlo</span>
                <span class="n">_tr1dict</span><span class="p">[</span><span class="s">&#39;stel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr1</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stel</span>

            <span class="n">mat_struct</span><span class="p">[</span><span class="s">&#39;stats_tr1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tr1dict</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="s">&#39;stats_tr2&#39;</span><span class="p">):</span>

            <span class="n">t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>

            <span class="n">_tr2dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;network&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                        <span class="s">&#39;station&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">station</span><span class="p">,</span>
                        <span class="s">&#39;location&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                        <span class="s">&#39;channel&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
                        <span class="s">&#39;sampling_rate&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                        <span class="s">&#39;starttime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                        <span class="s">&#39;endtime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span>
                        <span class="s">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">long</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">npts</span><span class="p">)}</span>
            <span class="k">if</span> <span class="s">&#39;sac&#39;</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="p">:</span>
                <span class="n">_tr2dict</span><span class="p">[</span><span class="s">&#39;stla&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stla</span>
                <span class="n">_tr2dict</span><span class="p">[</span><span class="s">&#39;stlo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stlo</span>
                <span class="n">_tr2dict</span><span class="p">[</span><span class="s">&#39;stel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats_tr2</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stel</span>

            <span class="n">mat_struct</span><span class="p">[</span><span class="s">&#39;stats_tr2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_tr2dict</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="s">&#39;stats&#39;</span><span class="p">):</span>

            <span class="n">_stats</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;network&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                      <span class="s">&#39;station&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,</span>
                      <span class="s">&#39;location&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                      <span class="s">&#39;channel&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
                      <span class="s">&#39;sampling_rate&#39;</span><span class="p">:</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                      <span class="s">&#39;starttime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                      <span class="s">&#39;endtime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span>
                      <span class="s">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">long</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">)}</span>
            <span class="k">if</span> <span class="s">&#39;sac&#39;</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="p">:</span>
                <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;stla&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stla</span>
                <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;stlo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stlo</span>
                <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;stel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stel</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="p">,</span> \
                              <span class="p">[</span><span class="s">&#39;evla&#39;</span><span class="p">,</span> <span class="s">&#39;evlo&#39;</span><span class="p">,</span> <span class="s">&#39;evel&#39;</span><span class="p">,</span> <span class="s">&#39;az&#39;</span><span class="p">,</span> <span class="s">&#39;baz&#39;</span><span class="p">,</span> <span class="s">&#39;dist&#39;</span><span class="p">])):</span>
                    <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;evla&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">evla</span>
                    <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;evlo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">evlo</span>
                    <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;evel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">evel</span>
                    <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;az&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">az</span>
                    <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;baz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">baz</span>
                    <span class="n">_stats</span><span class="p">[</span><span class="s">&#39;dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">dist</span>

            <span class="n">mat_struct</span><span class="p">[</span><span class="s">&#39;stats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_stats</span>

        <span class="n">mat_var_name</span> <span class="o">=</span> <span class="s">&#39;corr_trace&#39;</span>
        <span class="n">mat_struct</span><span class="p">[</span><span class="n">mat_var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span>

        <span class="n">time</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="n">sio</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">time</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">),</span> <span class="n">mat_struct</span><span class="p">,</span><span class="n">oned_as</span><span class="o">=</span><span class="s">&#39;column&#39;</span><span class="p">)</span>
</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_convert_to_matlab_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">base_name</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&#39;trace&#39;</span><span class="p">)</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="n">base_dir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="s">&#39;./&#39;</span><span class="p">)</span>
        <span class="n">seconds</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
        <span class="n">is_corr</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;base_name&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;suffix&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;base_dir&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;seconds&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;is_corr&#39;</span><span class="p">)</span>
                          <span class="p">)</span>


<span class="n">X</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Stacks together arrays of compatible size.</span>

<span class="sd">    This function stacks (pile up) array with compatible size to create a</span>
<span class="sd">    matrix. This stack can be done row-wise (``axis=0``) or column-wise</span>
<span class="sd">    (``axis=1``). To achieve this behaviour in a function based environment</span>
<span class="sd">    like blockcanvas, it uses a ``global`` variable that persist between</span>
<span class="sd">    successive call to this routine.</span>
<span class="sd">    It must be taken into account that this global variable needs to be</span>
<span class="sd">    reseted by hand if it is necessary to restart the piling procedure</span>
<span class="sd">    (see also the function ``clear_global_X``).</span>

<span class="sd">    :type vect: :class:`~numpy.ndarray`</span>
<span class="sd">    :param vect: 1D Array to stack with the current global variable ``X``</span>
<span class="sd">    :type axis: int</span>
<span class="sd">    :param axis: Stacking axis. 0: row-wise, 1: column-wise</span>

<span class="sd">    :rtype X: :class:`~numpy.ndarray`</span>
<span class="sd">    :return: **X**: Global variable that holds the stacked data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">X</span>

    <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">vect</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vect</span><span class="p">,</span> <span class="p">(</span><span class="n">vect</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">X</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">vect</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">vect</span><span class="o">.</span><span class="n">size</span><span class="p">))])</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">vect</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">vect</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Exception occurred stacking data!!!&quot;</span>
            <span class="k">print</span> <span class="s">&quot;Exception: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span>

            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">fv</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">fv</span><span class="p">])</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">X</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_stack_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">axis</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;axis&#39;</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="s">&#39;along axis 0:columnwise 1:rowwise&#39;</span><span class="p">))</span>
    

<span class="k">def</span> <span class="nf">clear_global_X</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Reset the global variable ``X`` to None &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">X</span>

    <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">submat_x</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">low_x</span><span class="p">,</span> <span class="n">high_x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract a sub-matrix from a matrix ``X`` along the x-axis (columns) &quot;&quot;&quot;</span>
    <span class="n">subX</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">low_x</span><span class="p">:</span><span class="n">high_x</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">subX</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_submat_x_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">low_x</span> <span class="o">=</span> <span class="n">Int</span>
        <span class="n">high_x</span> <span class="o">=</span> <span class="n">Int</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;low_x&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;high_x&#39;</span><span class="p">))</span>
    

<span class="k">def</span> <span class="nf">submat_y</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">low_y</span><span class="p">,</span> <span class="n">high_y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract a sub-matrix from a matrix ``X`` along the y-axis (rows).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subY</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">low_y</span><span class="p">:</span><span class="n">high_y</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">subY</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_submat_y_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">low_y</span> <span class="o">=</span> <span class="n">Int</span>
        <span class="n">high_y</span> <span class="o">=</span> <span class="n">Int</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;low_y&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;high_y&#39;</span><span class="p">))</span>
    

<span class="k">def</span> <span class="nf">nd_mat_center_part</span><span class="p">(</span><span class="n">ndmat</span><span class="p">,</span> <span class="n">win_len</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract the &quot;central&quot; part of a matrix.</span>

<span class="sd">    Extract the &quot;central&quot; part of size ``win_len`` from a matrix ``X`` along</span>
<span class="sd">    the specified axis. The center is the sample with zero referenced index</span>
<span class="sd">    floor((X.shape[axis]-1)/2). If ``win_len`` is an even number the center in</span>
<span class="sd">    the output will similarily be at floor((win_len-1)/2).</span>

<span class="sd">    :type ndmat: :class:`~numpy.ndarray`</span>
<span class="sd">    :param ndmat: matrix to take the central part</span>
<span class="sd">    :type win_len: int</span>
<span class="sd">    :param win_len: central windows length</span>
<span class="sd">    :type axis: int</span>
<span class="sd">    :param axis: axis where to act</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">ndmat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">row</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">row</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">center</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">win_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)])</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">lower</span> <span class="o">+</span> <span class="n">win_len</span><span class="p">])</span>
        <span class="n">cent_mat</span> <span class="o">=</span> <span class="n">ndmat</span><span class="p">[</span><span class="n">lower</span><span class="p">:</span><span class="n">upper</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">col</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">center</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">win_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)])</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">col</span><span class="p">,</span> <span class="n">lower</span> <span class="o">+</span> <span class="n">win_len</span><span class="p">])</span>
        <span class="n">cent_mat</span> <span class="o">=</span> <span class="n">ndmat</span><span class="p">[:,</span> <span class="n">lower</span><span class="p">:</span><span class="n">upper</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;lower: </span><span class="si">%d</span><span class="se">\n</span><span class="s">center: </span><span class="si">%d</span><span class="se">\n</span><span class="s">upper: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cent_mat</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_nd_mat_center_part_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">win_len</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;win_len&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;axis&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">matrix_product</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Simple matrix product using np.dot &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">C</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_matrix_product_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">collapse_to_single_vect</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">select_portion</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">first_line</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> \
                            <span class="n">last_line</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Collapse a matrix to a single normalized vector along a defined axis.</span>

<span class="sd">    The normalizing factor is equal to the number of points in the chosen axis</span>
<span class="sd">    (i.e. when ``axis=0`` it collapse the matrix ``X`` to a single row</span>
<span class="sd">    obtained summing column-wise and dividing each sample by the number of</span>
<span class="sd">    rows of ``X``).</span>
<span class="sd">    It is also possible to control how many rows/columns will be collapsed</span>
<span class="sd">    passing ``select_portion==True`` and the two index ``first_line=0`` and</span>
<span class="sd">    ``last_line=100``: Only the 100 rows/columns in the passed interval will</span>
<span class="sd">    be collapsed.</span>

<span class="sd">    :type X: :class:`~numpy.ndarray`</span>
<span class="sd">    :param X: 2D array to collapse to 1D</span>
<span class="sd">    :type axis: int</span>
<span class="sd">    :param axis: Collapsing axis. 0: row-wise, 1: column-wise</span>
<span class="sd">    :type select_portion: bool</span>
<span class="sd">    :param select_portion: If collapse a certain numbers of lines instead of</span>
<span class="sd">        the whole matrix</span>
<span class="sd">    :type first_line: int</span>
<span class="sd">    :param first_line: If ``selected_portion==True`` it says at which index</span>
<span class="sd">        starting selecting lines to collapse</span>
<span class="sd">    :type last_line: int</span>
<span class="sd">    :param last_line: If ``selected_portion==True`` it says at which index</span>
<span class="sd">        ending selecting lines to collapse</span>

<span class="sd">    :rtype: :class:`~numpy.ndarray`</span>
<span class="sd">    :return: **coll_array**: 1D array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">select_portion</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">first_line</span><span class="p">:</span><span class="n">last_line</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">select_portion</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">first_line</span><span class="p">:</span><span class="n">last_line</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">coll_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="k">return</span> <span class="n">coll_array</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_collapse_to_single_vect_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        
        <span class="n">axis</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">select_portion</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">first_line</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">last_line</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;axis&#39;</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="s">&#39;axis (0:row-wise, 1:col-wise)&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;select_portion&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;first_line&#39;</span><span class="p">,</span> <span class="n">enabled_when</span><span class="o">=</span><span class="s">&#39;select_portion==True&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;last_line&#39;</span><span class="p">,</span> <span class="n">enabled_when</span><span class="o">=</span><span class="s">&#39;select_portion==True&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">find_comb</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">is_mat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find all possible combinations written in the filenames</span>

<span class="sd">    Checks all the filenames in a directory to find all possible</span>
<span class="sd">    combinations of stations that have been created.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_pattern</span> <span class="o">=</span> <span class="s">&#39;*.mat&#39;</span>
    <span class="n">files_list1</span> <span class="o">=</span> <span class="n">dir_read</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">f_pattern</span><span class="p">,</span> <span class="n">sort_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">comb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file_full_name</span> <span class="ow">in</span> <span class="n">files_list1</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">file_full_name</span><span class="p">)</span>
        <span class="n">filename</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">filename_parts</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">suffix</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">filename_parts</span> <span class="o">=</span> <span class="n">filename_parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_mat</span><span class="p">:</span>
            <span class="n">filename_parts</span> <span class="o">=</span> <span class="n">filename_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filename_parts</span> <span class="o">=</span> <span class="n">filename_parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">ccomb</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filename_parts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ccomb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
            <span class="n">comb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccomb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">comb</span>


<span class="k">def</span> <span class="nf">split_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">gday</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ctime</span> <span class="o">=</span> <span class="n">gday</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">cdate</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">cdate</span>


<div class="viewcode-block" id="from_str_to_datetime"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.from_str_to_datetime.html#miic.core.miic_utils.from_str_to_datetime">[docs]</a><span class="k">def</span> <span class="nf">from_str_to_datetime</span><span class="p">(</span><span class="n">str_date</span><span class="p">,</span> <span class="n">datetimefmt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a dash separated string date in a datetime object.&quot;&quot;&quot;</span>
    <span class="n">ctime</span> <span class="o">=</span> <span class="n">str_date</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">datetimefmt</span><span class="p">:</span>
        <span class="n">cdate</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cdate</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ctime</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">cdate</span>

</div>
<span class="k">def</span> <span class="nf">extract_time_vect</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract time vector from filenames.</span>

<span class="sd">    Extract the time vector relative to a group of files stored in the same</span>
<span class="sd">    directory with a standatd filename:</span>
<span class="sd">    &quot;Year&quot;_&quot;trace&quot;_&quot;pattern&quot;+&quot;.mat&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_pattern</span> <span class="o">=</span> <span class="s">&#39;*&#39;</span> <span class="o">+</span> <span class="n">pattern</span> <span class="o">+</span> <span class="s">&#39;*.mat&#39;</span>
    <span class="n">files_list1</span> <span class="o">=</span> <span class="n">dir_read</span><span class="p">(</span><span class="n">base_dir</span><span class="o">=</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">f_pattern</span><span class="p">,</span> \
                           <span class="n">sort_flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">time_vect</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">celem1</span> <span class="ow">in</span> <span class="n">files_list1</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">f_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">celem1</span><span class="p">)</span>
        <span class="n">time_vect</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_file</span><span class="p">(</span><span class="n">f_name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">time_vect</span>


<span class="k">def</span> <span class="nf">norm1</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Matrix normalization.</span>

<span class="sd">    Normalize each row (column) of a matrix dividing it by the reference array</span>
<span class="sd">    obtained summing the matrix row-wise (column-wise).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">denom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">app</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">denom</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">X</span>


<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Transpose the matrix ``X`` &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_transpose_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">reshape_mat_to_vect</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reshape the matrix elements to obtain a 1D array.</span>

<span class="sd">    If ``axis==0`` the returned 1D array is a row vector of shape [1,X.size]</span>
<span class="sd">    otherwise , when ``axis==1``, it is a column vector of shape [X.size,1]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vec_x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">vec_x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">vec_x</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_reshape_mat_to_vect_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        
        <span class="n">axis</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;axis&#39;</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="s">&#39;axis (0:col, 1:row)&#39;</span><span class="p">))</span>
    

<span class="k">def</span> <span class="nf">nd_nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Replace NaNs with 0 and +-Inf with +-large number.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_clean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_clean</span>


<span class="k">def</span> <span class="nf">datetime_list</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="mf">86400.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a list of datetime objects.</span>

<span class="sd">    Create a list of regularly spaces :class:~`datetime.datetime` objects.</span>
<span class="sd">    The first element is ``start`` and the last element is smaller than</span>
<span class="sd">    ``end``. The distance between elements is ``inc``</span>

<span class="sd">    :type start: :class:~`datetime.datetime` object or string as defined in</span>
<span class="sd">        miic.core.miic_utils.convert_time.</span>
<span class="sd">    :param start: first elemet of list</span>
<span class="sd">    :type end: :class:~`datetime.datetime` object or string as defined in</span>
<span class="sd">        miic.core.miic_utils.convert_time.</span>
<span class="sd">    :param end: termiation of list</span>
<span class="sd">    :type inc: float</span>
<span class="sd">    :param inc: spacing between elements in seconds</span>

<span class="sd">    :rtype time_list: list</span>
<span class="sd">    :return: **time_list**: list of datetime objects</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_date</span> <span class="o">=</span> <span class="n">convert_time</span><span class="p">([</span><span class="n">start</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end_date</span> <span class="o">=</span> <span class="n">convert_time</span><span class="p">([</span><span class="n">end</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">date_inc</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">inc</span><span class="p">)</span>

    <span class="n">time_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_date</span><span class="p">]</span>
    <span class="n">next_t</span> <span class="o">=</span> <span class="n">time_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">date_inc</span>

    <span class="k">while</span> <span class="n">next_t</span> <span class="o">&lt;</span> <span class="n">end_date</span><span class="p">:</span>
        <span class="n">time_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_t</span><span class="p">)</span>
        <span class="n">next_t</span> <span class="o">=</span> <span class="n">time_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">date_inc</span>

    <span class="k">return</span> <span class="n">time_list</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_datetime_list_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&quot;2000-01-01&quot;</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&quot;2001-01-01&quot;</span><span class="p">)</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="s">&quot;86400.&quot;</span><span class="p">)</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;start&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;end&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;inc&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="n">n_trace</span><span class="p">,</span> <span class="n">std_comb</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create the list of combinations.</span>

<span class="sd">    Create the list of possible combinations between a specified number</span>
<span class="sd">    of traces. Several different possibility are available:</span>
<span class="sd">    ``Auto-corr`` andgenerates a list of tuples of this form (n,n)</span>
<span class="sd">    ``Full-corr`` generates all the possible tuples of this form (n,m)</span>
<span class="sd">    where ``n!=m`` and ``0 &lt;= n &lt; n_trace`` and ``0 &lt;= m &lt; n_trace``.</span>
<span class="sd">    ``Single-corr``,k generates all the possible tuples of the form (n,k)</span>
<span class="sd">                  or (k,n) for n!=k, such that always the first number is smaller than the second.</span>
<span class="sd">                  If k&lt;0 or &gt;=n, return empty list</span>

<span class="sd">    :type n_trace: int</span>
<span class="sd">    :param n_trace: Number of traces</span>
<span class="sd">    :type std_comb: enum</span>
<span class="sd">    :param std_comb: Type of combination to generate. It can be one of:</span>
<span class="sd">            [&#39;Auto-corr&#39;,&#39;Full-corr&#39;]</span>

<span class="sd">    :rtype: list of tuples</span>
<span class="sd">    :return: **comb**: List of possible combinations. For example,</span>
<span class="sd">        if ``n_trace==3`` and ``std_comb==&#39;Auto-corr&#39;`` -&gt;</span>
<span class="sd">        comb = [(0,0),(1,1),(2,2)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">comb</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">std_comb</span> <span class="o">==</span> <span class="s">&#39;Auto-corr&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trace</span><span class="p">):</span>
            <span class="n">comb</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">std_comb</span> <span class="o">==</span> <span class="s">&#39;Full-corr&#39;</span><span class="p">:</span>
        <span class="n">comb</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trace</span><span class="p">)</span> \
                       <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_trace</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">std_comb</span> <span class="o">==</span> <span class="s">&#39;Single-corr&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">n_trace</span><span class="p">:</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
            <span class="n">comb</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n_trace</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;Unknown combination type </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">std_comb</span>
    <span class="k">return</span> <span class="n">comb</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_combinations_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">n_trace</span> <span class="o">=</span> <span class="n">Int</span>
        <span class="n">std_comb</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">(</span><span class="s">&#39;Auto-corr&#39;</span><span class="p">,</span> <span class="s">&#39;Full-corr&#39;</span><span class="p">)</span>
    
        <span class="n">_type_c</span> <span class="o">=</span> <span class="n">List</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;n_trace&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;std_comb&#39;</span><span class="p">,</span>
                               <span class="n">enabled_when</span><span class="o">=</span><span class="s">&quot;s_type==&#39;Standard&#39;&quot;</span><span class="p">,</span>
                               <span class="n">style</span><span class="o">=</span><span class="s">&#39;custom&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;_type_c&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s">&#39;readonly&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Combinations&#39;</span><span class="p">),</span>
                          <span class="n">resizable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;SELECTION&#39;</span><span class="p">,</span>
                          <span class="n">buttons</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;OK&#39;</span><span class="p">,</span> <span class="s">&#39;Help&#39;</span><span class="p">])</span>
    
        <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_c</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_comb</span> <span class="o">=</span> <span class="p">[]</span>
    
        <span class="k">def</span> <span class="nf">_n_trace_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_c</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_comb</span><span class="p">)</span>
    
        <span class="k">def</span> <span class="nf">_std_comb_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_c</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_comb</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">comb_with_missed_stations</span><span class="p">(</span><span class="n">n_stations</span><span class="p">,</span> <span class="n">std_comb</span><span class="p">,</span> <span class="n">missed_stations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create the list of combinations.</span>

<span class="sd">    Create the list of possible combinations between a specified number</span>
<span class="sd">    of stations. Two different possibility are available: ``Auto-corr`` and</span>
<span class="sd">    ``Full-corr``. The former generates a list of tuples of this form (n,n)</span>
<span class="sd">    while the latter generates all the possible tuples of this form (n,m)</span>
<span class="sd">    where ``n!=m`` and ``0 &lt;= n &lt; n_trace`` and ``0 &lt;= m &lt; n_trace``.</span>
<span class="sd">    It handles missed stations so that every station listed in the</span>
<span class="sd">    ``missed_stations`` parameter will not be included in the final list of</span>
<span class="sd">    combinations.</span>

<span class="sd">    :type n_trace: int</span>
<span class="sd">    :param n_trace: Number of traces</span>
<span class="sd">    :type std_comb: enum</span>
<span class="sd">    :param std_comb: Type of combination to generate. It can be one of:</span>
<span class="sd">            [&#39;Auto-corr&#39;,&#39;Full-corr&#39;]</span>
<span class="sd">    :type missed_stations: list</span>
<span class="sd">    :param missed_stations: Missed stations list (e.g. [2,5,6])</span>

<span class="sd">    :rtype: list of tuples</span>
<span class="sd">    :return: **comb**: List of possible combinations. For example,</span>
<span class="sd">        if ``n_trace==3`` and ``std_comb==&#39;Auto-corr&#39;`` -&gt;</span>
<span class="sd">        comb = [(0,0),(1,1),(2,2)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">comb</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">std_comb</span> <span class="o">==</span> <span class="s">&#39;Auto-corr&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_stations</span><span class="p">):</span>
            <span class="n">comb</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">std_comb</span> <span class="o">==</span> <span class="s">&#39;Full-corr&#39;</span><span class="p">:</span>
        <span class="n">comb</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_stations</span><span class="p">)</span> \
                       <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_stations</span><span class="p">)</span> \
                       <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_stations</span> <span class="ow">and</span> \
                       <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_stations</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">comb</span>


<span class="k">def</span> <span class="nf">nd_save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Save an ndarray in the original NumPy format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_nd_save_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">File</span><span class="p">()</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">nd_load</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load an ndarray from a file in NumPy format (.npy)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_nd_load_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">File</span><span class="p">()</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">nd_toList</span><span class="p">(</span><span class="n">ndv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert a numpz arraz to a list &quot;&quot;&quot;</span>
    <span class="n">list_a</span> <span class="o">=</span> <span class="n">ndv</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">list_a</span>


<div class="viewcode-block" id="load_matlab_file"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.load_matlab_file.html#miic.core.miic_utils.load_matlab_file">[docs]</a><span class="k">def</span> <span class="nf">load_matlab_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load variables from MatLab file.</span>

<span class="sd">    Load all variables stored in a MatLab (.mat) file and return them</span>
<span class="sd">    as a dictionary with the keys being the name of the variables. The</span>
<span class="sd">    functionality is based on :class:`~scipy.io.loadmat` and inherits</span>
<span class="sd">    its capabilities and limitations.</span>

<span class="sd">    :type filename: string</span>
<span class="sd">    :param filename: Name of the file to be loaded.</span>

<span class="sd">    :rtype: dictionary</span>
<span class="sd">    :return: **mat_vars**: dictionary holding the variables found in the file.</span>
<span class="sd">        The key is the name of the variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat_vars</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat_vars</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_load_matlab_file_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">File</span><span class="p">()</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">enum_list</span><span class="p">(</span><span class="n">ls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Enumerate a list &quot;&quot;&quot;</span>
    <span class="n">ls_enum</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ls_enum</span>


<span class="k">def</span> <span class="nf">to_str</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert a variable to string &quot;&quot;&quot;</span>
    <span class="n">svar</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">svar</span>


<span class="k">def</span> <span class="nf">nd_size</span><span class="p">(</span><span class="n">nda</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return and print the shape of an ndarray &quot;&quot;&quot;</span>
    <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">nda</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">print</span> <span class="s">&quot;row: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">row</span>
    <span class="k">print</span> <span class="s">&quot;col: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">col</span>
    <span class="k">return</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span>


<span class="k">def</span> <span class="nf">fold_acausal</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Fold the acausal part of an Auto/Cross corr. matrix and mirror it &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">[:,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> \
                             <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">X_fol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">X</span><span class="p">[:,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:]))</span>
    <span class="k">return</span> <span class="n">X_fol</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_fold_acausal_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>



<div class="viewcode-block" id="lat_lon_ele_load"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.lat_lon_ele_load.html#miic.core.miic_utils.lat_lon_ele_load">[docs]</a><span class="k">def</span> <span class="nf">lat_lon_ele_load</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load lat lon and ele from a tab delimited file.</span>

<span class="sd">    This function load lat, lon and ele from a tab delimited file into a</span>
<span class="sd">    pandas DataFrame so that those informaiton can be retrived using its</span>
<span class="sd">    wide capabilities.</span>

<span class="sd">    :type filename: full path filename</span>
<span class="sd">    :param filename: The file to load</span>

<span class="sd">    :rtype: :class:`~pandas.DataFrame`</span>
<span class="sd">    :return: **df**: Pandas DataFrame with stations name as index and lat, lon,</span>
<span class="sd">        ele as columns</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">read_table</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_lat_lon_ele_load_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">filename</span> <span class="o">=</span> <span class="n">File</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="trace_calc_az_baz_dist"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.trace_calc_az_baz_dist.html#miic.core.miic_utils.trace_calc_az_baz_dist">[docs]</a><span class="k">def</span> <span class="nf">trace_calc_az_baz_dist</span><span class="p">(</span><span class="n">tr1</span><span class="p">,</span> <span class="n">tr2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return azimut, back azimut and distance between tr1 and tr2</span>
<span class="sd">    This funtions calculates the azimut, back azimut and distance between tr1</span>
<span class="sd">    and tr2 if both have geo information in their stats dictonary.</span>
<span class="sd">    Required fields are:</span>
<span class="sd">        tr.stats.sac.stla</span>
<span class="sd">        tr.stats.sac.stlo</span>

<span class="sd">    :type tr1: :class:`~obspy.core.trace.Trace`</span>
<span class="sd">    :param tr1: First trace to account</span>
<span class="sd">    :type tr2: :class:`~obspy.core.trace.Trace`</span>
<span class="sd">    :param tr2: Second trace to account</span>

<span class="sd">    :rtype: float</span>
<span class="sd">    :return: **az**: Azimut angle between tr1 and tr2</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    :return: **baz**: Back azimut angle between tr1 and tr2</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    :return: **dist**: Distance between tr1 and tr2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tr1</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;tr1 must be an obspy Trace object.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tr2</span><span class="p">,</span> <span class="n">Trace</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;tr2 must be an obspy Trace object.&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">obspy.geodetics</span> <span class="kn">import</span> <span class="n">gps2dist_azimuth</span> 
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Missed obspy funciton gps2dist_azimuth&quot;</span>
        <span class="k">print</span> <span class="s">&quot;Update obspy.&quot;</span>
        <span class="k">return</span>

    <span class="n">dist</span><span class="p">,</span> <span class="n">az</span><span class="p">,</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">gps2dist_azimuth</span><span class="p">(</span><span class="n">tr1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stla</span><span class="p">,</span> \
                                     <span class="n">tr1</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stlo</span><span class="p">,</span> \
                                     <span class="n">tr2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stla</span><span class="p">,</span> \
                                     <span class="n">tr2</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stlo</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">az</span><span class="p">,</span> <span class="n">baz</span><span class="p">,</span> <span class="n">dist</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_trace_calc_az_baz_dist_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">nextpow2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the smalest integer number larger than ``n`` that is a power</span>
<span class="sd">    of 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">m_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">m_f</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">m_i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


<span class="c">##############################################################################</span>
<span class="c"># Data handling                                                              #</span>
<span class="c">##############################################################################</span>


<span class="k">def</span> <span class="nf">select_item_from_list</span><span class="p">(</span><span class="n">in_list</span><span class="p">,</span> <span class="n">item_pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select a specified item from a list.</span>

<span class="sd">    Select the ``item_pos`` element from the list ``in_list`` and return it.</span>

<span class="sd">    :type in_list: list</span>
<span class="sd">    :param in_list: list from which item is to be extracted</span>
<span class="sd">    :type item_pos: int</span>
<span class="sd">    :param item_pos: position of the item to be extracted from the list</span>

<span class="sd">    :rtype: item</span>
<span class="sd">    :return: **item**: item_pos element of the list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># check input</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;input variable in_list is not a list.&#39;</span><span class="p">)</span>

    <span class="n">item</span> <span class="o">=</span> <span class="n">in_list</span><span class="p">[</span><span class="n">item_pos</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">item</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_select_item_from_list_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">item_pos</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;item_pos&#39;</span><span class="p">))</span>
    

<div class="viewcode-block" id="select_var_from_dict"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.select_var_from_dict.html#miic.core.miic_utils.select_var_from_dict">[docs]</a><span class="k">def</span> <span class="nf">select_var_from_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Select variable from dictionary.</span>

<span class="sd">    Select a variable (value) associated to the key ``key``</span>
<span class="sd">    from a dictionary and return the variable.</span>

<span class="sd">    :type dictionary: dictionary</span>
<span class="sd">    :param dictionary: dictionary holding the variable in associated to the</span>
<span class="sd">            key ``key``</span>
<span class="sd">    :type key: string</span>
<span class="sd">    :param key: name of the key associated to the varable to select</span>

<span class="sd">    :rtype: variable</span>
<span class="sd">    :return: **variable**: variable stored associated to the key ``key``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># check input</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;input variable dictionary is not a dictionary.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&#39;InputError: dictionary has no key key&#39;</span>

    <span class="k">return</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_select_var_from_dict_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">Str</span><span class="p">()</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;key&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="add_var_to_dict"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.add_var_to_dict.html#miic.core.miic_utils.add_var_to_dict">[docs]</a><span class="k">def</span> <span class="nf">add_var_to_dict</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">dictionary</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Add a variable to a dictionary.</span>

<span class="sd">    Add a variable to a dictionary as value associated to the key ``key``.</span>

<span class="sd">    :type dictionary: dict</span>
<span class="sd">    :param dictionary: dictionary to which the variable should be added.</span>
<span class="sd">        If None a new dictionary is created.</span>
<span class="sd">    :type key: str</span>
<span class="sd">    :param key: name of the key to which the vradiable is to be associated</span>
<span class="sd">            with.</span>
<span class="sd">    :type variable: any</span>
<span class="sd">    :param data that should be added to the dictionary</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **dictionary**: extended or new dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;input variable dictionary is not a dictionary.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;input variable key must be a string.&#39;</span><span class="p">)</span>

    <span class="c"># check input</span>
    <span class="k">if</span> <span class="n">dictionary</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>

    <span class="k">return</span> <span class="n">dictionary</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_add_var_to_dict_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">Str</span><span class="p">()</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;string&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">print_keys_from_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Print the keys present in a dictionary.</span>

<span class="sd">    Print the keys present in dictionary ``dictionary`` and return the list</span>
<span class="sd">    a dictionary holding the list of keys and the type of the associated data.</span>

<span class="sd">    :type dictionary: dict</span>
<span class="sd">    :param dictionary: dictionary of which the keys are to be printed</span>

<span class="sd">    :rtype: key_list</span>
<span class="sd">    :return: **key_list**: dictionary holding a list of the keys and the data</span>
<span class="sd">             types</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># check input</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;input variable dictionary is not a dictionary.&#39;</span><span class="p">)</span>

    <span class="n">key_list</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;keys&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s">&#39;types&#39;</span><span class="p">:</span> <span class="p">[]}</span>
    <span class="c"># print the keys</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">key_list</span><span class="p">[</span><span class="s">&#39;keys&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">key_list</span><span class="p">[</span><span class="s">&#39;types&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> : </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">key_list</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_print_keys_from_dict_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<div class="viewcode-block" id="save_dict_to_matlab_file"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.save_dict_to_matlab_file.html#miic.core.miic_utils.save_dict_to_matlab_file">[docs]</a><span class="k">def</span> <span class="nf">save_dict_to_matlab_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Save a dictionary to a matlab file.</span>

<span class="sd">    Save values stored in a dictionary as variables having the name of the key</span>
<span class="sd">    in a matlab file.</span>

<span class="sd">    :type dicitonary: dict</span>
<span class="sd">    :param dictionary: dicitonary to be saved</span>
<span class="sd">    :type filename: str</span>
<span class="sd">    :param filename: name of the matlab file to be created</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#print &#39;saving to %s&#39; % filename</span>
    <span class="n">savemat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">oned_as</span><span class="o">=</span><span class="s">&#39;row&#39;</span><span class="p">)</span>

    <span class="k">return</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_save_dict_to_matlab_file_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">Str</span><span class="p">()</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="convert_time"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.convert_time.html#miic.core.miic_utils.convert_time">[docs]</a><span class="k">def</span> <span class="nf">convert_time</span><span class="p">(</span><span class="n">time_vect</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert a list/array of timestaps in a array of datetime.datetime obj</span>

<span class="sd">    This fucntion does the conversion of a list/array of string in a list/array</span>
<span class="sd">    of :class:`~datetime.datetime` objects. The time format allowed for the</span>
<span class="sd">    string representation is one of:</span>
<span class="sd">    - %Y-%m-%dT%H:%M:%S.%fZ</span>
<span class="sd">    - %Y-%m-%d %H:%M:%S.%f</span>
<span class="sd">    - %Y-%m-%d %H:%M:%S</span>
<span class="sd">    - %Y-%m-%d</span>

<span class="sd">    :type time_vect: list or :class:`~numpy.ndarray` of String</span>
<span class="sd">    :param time_vect: List/array of timestamp in string format.</span>

<span class="sd">    :rtype: :class:`~numpy.ndarray` of :class:`~datetime.datetime` objs</span>
<span class="sd">    :return: Array of :class:`~datetime.datetime` objects</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_vect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
        <span class="n">rtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_vect</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rtime</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">time_vect</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">time_vect</span> <span class="o">=</span> <span class="n">time_vect</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">rtime</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_vect</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ctime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                                              <span class="s">&quot;%Y-%m-</span><span class="si">%d</span><span class="s">T%H:%M:%S.</span><span class="si">%f</span><span class="s">Z&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ctime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                                               <span class="s">&quot;%Y-%m-</span><span class="si">%d</span><span class="s"> %H:%M:%S.</span><span class="si">%f</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ctime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                                                  <span class="s">&quot;%Y-%m-</span><span class="si">%d</span><span class="s"> %H:%M:%S&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ctime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                                                           <span class="s">&quot;%Y-%m-</span><span class="si">%d</span><span class="s">&quot;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">print</span> <span class="n">e</span>
                        <span class="k">print</span> <span class="s">&quot;Time format error&quot;</span>
                        <span class="k">return</span> <span class="bp">None</span>

        <span class="n">rtime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ctime</span><span class="p">)</span>
    <span class="n">rtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rtime</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rtime</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_convert_time_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<div class="viewcode-block" id="convert_time_to_string"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.convert_time_to_string.html#miic.core.miic_utils.convert_time_to_string">[docs]</a><span class="k">def</span> <span class="nf">convert_time_to_string</span><span class="p">(</span><span class="n">time_vect</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a list/array of datetime.datetime obj to an array of strings</span>

<span class="sd">    This fucntion does the conversion of a list/array of</span>
<span class="sd">    of :py:class:`~datetime.datetime` objects to an array of time strings of</span>
<span class="sd">    the format of the format %Y-%m-%d %H:%M:%S.%f.</span>
<span class="sd">    The list/array of time strings must have a format know to</span>
<span class="sd">    :py:class:``~miic.core.miic_utils.convert_time``.</span>

<span class="sd">    :type time_vect: :class:`~numpy.ndarray` of :py:class:`~datetime.datetime`</span>
<span class="sd">        objs or timestamps in string format</span>
<span class="sd">    :param time_vect: List/Array of time stamps</span>

<span class="sd">    :rtype: :class:`~numpy.ndarray` of String</span>
<span class="sd">    :return: Array of timestamp in string format.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rtime</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_vect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
        <span class="n">time_vect</span> <span class="o">=</span> <span class="n">convert_time</span><span class="p">(</span><span class="n">time_vect</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_vect</span><span class="p">:</span>
        <span class="n">rtime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&quot;%Y-%m-</span><span class="si">%d</span><span class="s"> %H:%M:%S.</span><span class="si">%f</span><span class="s">&quot;</span><span class="p">))</span>

    <span class="n">rtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rtime</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rtime</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_convert_time_to_string_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">correlation_subdir_name</span><span class="p">(</span><span class="n">date</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create the path name to a sub folder with YEAR/JDAY format</span>

<span class="sd">    The path will have the following structure:</span>
<span class="sd">    YEAR/JDAY</span>
<span class="sd">    </span>
<span class="sd">    :type date: datetime.datetime or obspy.UTCDateTime</span>
<span class="sd">    :param date: date of the data</span>
<span class="sd">    </span>
<span class="sd">    :rtype: str</span>
<span class="sd">    :return: name of subpath</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">date</span><span class="p">,</span><span class="n">UTCDateTime</span><span class="p">):</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="n">datetime</span>

    <span class="n">subpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">year</span><span class="p">),</span><span class="s">&quot;</span><span class="si">%03d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">date</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span><span class="o">.</span><span class="n">tm_yday</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subpath</span>



<div class="viewcode-block" id="serial_date_from_datetime"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.serial_date_from_datetime.html#miic.core.miic_utils.serial_date_from_datetime">[docs]</a><span class="k">def</span> <span class="nf">serial_date_from_datetime</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts a datetime.datetime object into a number as toordinal but</span>
<span class="sd">    including seconds.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sd</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">toordinal</span><span class="p">()</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)</span><span class="o">/</span><span class="mi">24</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">)</span><span class="o">/</span><span class="mi">1440</span> <span class="o">+</span> \
        <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">)</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span><span class="p">)</span><span class="o">/</span><span class="mi">1000000</span><span class="p">)</span><span class="o">/</span><span class="mi">86400</span>
    <span class="k">return</span> <span class="n">sd</span>

</div>
<span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return the flattened version of the input array x</span>

<span class="sd">    This funciton works with all :class:`~collections.Iterable` that can be</span>
<span class="sd">    nested in an irregular fashion.</span>

<span class="sd">    .. rubric: Example</span>

<span class="sd">    &gt;&gt;&gt;L=[[[1, 2, 3], [4, 5]], 6]</span>
<span class="sd">    &gt;&gt;&gt;flatten(L)</span>
<span class="sd">    [1, 2, 3, 4, 5, 6]</span>

<span class="sd">    :type x: :class:`~collections.Iterable`</span>
<span class="sd">    :param: Iterable to be flattened</span>

<span class="sd">    :rtype: list</span>
<span class="sd">    :return: x as a flattened list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_flatten_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">flatten_recarray</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Flatten a recarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flat_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;dtype&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s">&#39;names&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">field</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="p">[]:</span>
                        <span class="n">flat_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">flat_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">field</span><span class="p">})</span>
                <span class="k">return</span> <span class="n">flat_dict</span>
    <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="save_dv"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.save_dv.html#miic.core.miic_utils.save_dv">[docs]</a><span class="k">def</span> <span class="nf">save_dv</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Save dv dictionary</span>

<span class="sd">    Note: Masked array have to be considered with care because masked</span>
<span class="sd">        values will be substituted with the associated ``fill_value``</span>
<span class="sd">        of the corresponding object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dv_check</span><span class="p">(</span><span class="n">dv</span><span class="p">)[</span><span class="s">&#39;is_incomplete&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Error: dv is not a valid dv dictionary.&quot;</span><span class="p">)</span>

    <span class="c"># Adjust masked arrays. It is better to do that explicitely than</span>
    <span class="c"># relay on the save function</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dv</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dv</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dv</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dv</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">if</span> <span class="n">pattern</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="n">flatten_recarray</span><span class="p">(</span><span class="n">dv</span><span class="p">[</span><span class="s">&#39;stats&#39;</span><span class="p">])</span>

        <span class="c"># Fix the problem of havin empty list instead of empty strings</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="n">stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s">&#39;network&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> \
                  <span class="n">stats</span><span class="p">[</span><span class="s">&#39;station&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> \
                  <span class="n">stats</span><span class="p">[</span><span class="s">&#39;location&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> \
                  <span class="n">stats</span><span class="p">[</span><span class="s">&#39;channel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">suffix</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
        <span class="n">vchange_file_name</span> <span class="o">=</span> <span class="s">&#39;vchange_full_&#39;</span> <span class="o">+</span> \
            <span class="n">pattern</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">suffix</span> <span class="o">+</span> <span class="s">&#39;.mat&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vchange_file_name</span> <span class="o">=</span> <span class="s">&#39;vchange_full_&#39;</span> <span class="o">+</span> <span class="n">pattern</span> <span class="o">+</span> <span class="s">&#39;.mat&#39;</span>

    <span class="n">savemat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">vchange_file_name</span><span class="p">),</span> <span class="n">dv</span><span class="p">,</span> <span class="n">oned_as</span><span class="o">=</span><span class="s">&#39;column&#39;</span><span class="p">)</span>

</div>
<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_save_dv_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
    
        <span class="n">save_dir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">()</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&#39;PFPF.UV05UV12.0000.HHZHHZ&#39;</span><span class="p">)</span>
        <span class="n">use_pattern</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;suffix&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;filename suffix&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;save_dir&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;use_pattern&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;pattern&#39;</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="s">&#39;Pattern (optional)&#39;</span><span class="p">,</span>
                               <span class="n">enabled_when</span><span class="o">=</span><span class="s">&#39;use_pattern&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_timestamp</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">mktime</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">timetuple</span><span class="p">())</span> <span class="o">+</span> <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mf">1000000.0</span>
    

<span class="k">def</span> <span class="nf">_stats_dict_from_obj</span><span class="p">(</span><span class="n">stats</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert the obspy stats object to a dictionary used by miic</span>
<span class="sd">  </span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="n">stats_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;network&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="o">.</span><span class="n">network</span><span class="p">,</span>
                <span class="s">&#39;station&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,</span>
                <span class="s">&#39;location&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                <span class="s">&#39;channel&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
                <span class="s">&#39;sampling_rate&#39;</span><span class="p">:</span> <span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span><span class="p">,</span>
                <span class="s">&#39;starttime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span>
                <span class="s">&#39;endtime&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">,</span>
                <span class="s">&#39;npts&#39;</span><span class="p">:</span> <span class="nb">long</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">npts</span><span class="p">)}</span>
    <span class="k">if</span> <span class="s">&#39;sac&#39;</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
        <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;stla&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stla</span>
        <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;stlo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stlo</span>
        <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;stel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">stel</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="p">,</span>
                    <span class="p">[</span><span class="s">&#39;evla&#39;</span><span class="p">,</span> <span class="s">&#39;evlo&#39;</span><span class="p">,</span> <span class="s">&#39;evel&#39;</span><span class="p">,</span> <span class="s">&#39;az&#39;</span><span class="p">,</span> <span class="s">&#39;baz&#39;</span><span class="p">,</span> <span class="s">&#39;dist&#39;</span><span class="p">])):</span>
             <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;evla&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">evla</span>
             <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;evlo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">evlo</span>
             <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;evel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">evel</span>
             <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;az&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">az</span>
             <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;baz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">baz</span>
             <span class="n">stats_dict</span><span class="p">[</span><span class="s">&#39;dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">sac</span><span class="o">.</span><span class="n">dist</span>
    
    <span class="k">return</span> <span class="n">stats_dict</span> 


<span class="k">def</span> <span class="nf">_check_stats</span><span class="p">(</span><span class="n">stats</span><span class="p">):</span>

    <span class="n">ERRORS</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="n">flatten_recarray</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span>

    <span class="c"># Check the timing</span>
    <span class="n">starttime</span> <span class="o">=</span> <span class="n">convert_time</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s">&#39;starttime&#39;</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">endtime</span> <span class="o">=</span> <span class="n">convert_time</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s">&#39;endtime&#39;</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s">&#39;npts&#39;</span><span class="p">]</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s">&#39;sampling_rate&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">starttime</span> <span class="o">&gt;</span> <span class="n">endtime</span><span class="p">:</span>
        <span class="n">ERRORS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;starttime greater then endtime&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERRORS</span>

    <span class="c"># Delta T in seconds</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">_timestamp</span><span class="p">(</span><span class="n">endtime</span><span class="p">)</span> <span class="o">-</span> <span class="n">_timestamp</span><span class="p">(</span><span class="n">starttime</span><span class="p">)</span>
    <span class="n">expected_npts</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expected_npts</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="n">ERRORS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;npts not consistent with starttime, </span><span class="se">\</span>
<span class="s">            endtime and sampling_rate&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ERRORS</span>

    <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">_check_dict</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">keys_class</span><span class="p">):</span>

    <span class="n">is_incomplete</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">missed_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">wrong_classes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">cclass</span><span class="p">)</span> <span class="ow">in</span> <span class="n">keys_class</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">is_incomplete</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">missed_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Check class</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">cclass</span><span class="p">):</span>
                <span class="n">wrong_classes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">is_incomplete</span><span class="p">,</span> <span class="n">missed_keys</span><span class="p">,</span> <span class="n">wrong_classes</span>


<span class="k">def</span> <span class="nf">corr_check</span><span class="p">(</span><span class="n">corr_fun_struct</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Correlation function dictionary check</span>

<span class="sd">    This function test if the a loaded correlation function dictionary</span>
<span class="sd">    contains the requested keywords and if their corresponding value is of the</span>
<span class="sd">    proper class to continue the processing, e.g., recombining then to form a</span>
<span class="sd">    correlation matrix.</span>

<span class="sd">    Actually the requested keywords are:</span>
<span class="sd">        &#39;corr_trace&#39;  (not for the old_style corr_fun)</span>
<span class="sd">        &#39;stats&#39;</span>
<span class="sd">        &#39;stats_tr1&#39;</span>
<span class="sd">        &#39;stats_tr2&#39;</span>

<span class="sd">    and their class is, for all of them, :py:class:`numpy.ndarray`.</span>
<span class="sd">    The three &quot;stats&quot; objects are also checked for some &quot;main&quot; errors like</span>
<span class="sd">    the starttime greather then the endtime or a substaintial (greater then 1</span>
<span class="sd">    sample) disagreement between starttime, endtime, sampling_rate and npts.</span>

<span class="sd">    :type corr_fun_struct: dict</span>
<span class="sd">    :param corr_fun_struct: Correlation function dictionary</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **ret_dict**: dictionary that contains the following keys:</span>
<span class="sd">        *is_incomplete*: True if a keyword is missed</span>
<span class="sd">        *missed_keys*: list of missed keywords</span>
<span class="sd">        *wrong_class*: list of keyworkds which value is of a wrong class</span>
<span class="sd">        *ERROR_stats*: list of errors (strings) detected in the &#39;stats&#39; object</span>
<span class="sd">        *ERROR_stats_tr1*: list of errors (strings) detected in the</span>
<span class="sd">            &#39;stats_tr1&#39; object</span>
<span class="sd">        *ERROR_stats_tr2**: list of errors (strings) detected in the</span>
<span class="sd">            &#39;stats_tr2&#39; object</span>

<span class="sd">    ... rubric:: Notes</span>

<span class="sd">    If the correlation function have been saved to a matlab file and than</span>
<span class="sd">    reloaded, it is supposed that the stats onbjects have been flattened.</span>
<span class="sd">    For instance, this can be achieved doing the reload with the function</span>
<span class="sd">    :py:func:`~miic.core.miic_utils.mat_to_ndarray` setting the flag</span>
<span class="sd">    flatten to True (this is the default value)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;corr_trace&#39;</span><span class="p">,</span> <span class="s">&#39;stats&#39;</span><span class="p">,</span> <span class="s">&#39;stats_tr1&#39;</span><span class="p">,</span> <span class="s">&#39;stats_tr2&#39;</span><span class="p">]</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span>

    <span class="n">is_incomplete</span><span class="p">,</span> <span class="n">missed_keys</span><span class="p">,</span> <span class="n">wrong_classes</span> <span class="o">=</span> \
        <span class="n">_check_dict</span><span class="p">(</span><span class="n">corr_fun_struct</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">klass</span><span class="p">))</span>

    <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">corr_fun_struct</span><span class="p">[</span><span class="s">&#39;stats&#39;</span><span class="p">])</span>

    <span class="n">ERROR_stats_tr1</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats_tr1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats_tr1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats_tr1</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">corr_fun_struct</span><span class="p">[</span><span class="s">&#39;stats_tr1&#39;</span><span class="p">])</span>

    <span class="n">ERROR_stats_tr2</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats_tr2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats_tr2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats_tr2</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">corr_fun_struct</span><span class="p">[</span><span class="s">&#39;stats_tr2&#39;</span><span class="p">])</span>

    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;is_incomplete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_incomplete</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;missed_keys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_keys</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;wrong_classes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_classes</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats_tr1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats_tr1</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats_tr2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats_tr2</span>

    <span class="k">return</span> <span class="n">ret_dict</span>


<span class="k">def</span> <span class="nf">spectrogram_check</span><span class="p">(</span><span class="n">spectrogram</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Spectrogram dictionary check</span>

<span class="sd">    This function test if the a loaded spectrogram dictionary</span>
<span class="sd">    contains the requested keywords and if their corresponding value is of the</span>
<span class="sd">    proper class to continue the processing.</span>
<span class="sd">    </span>
<span class="sd">    the requested keywords and the corresponding types are:</span>
<span class="sd">        &#39;spec_mat&#39; : :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;stats&#39;    : dictionary of type stats</span>
<span class="sd">        &#39;frequency&#39;: :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;time&#39;       :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;unit&#39;     : string</span>
<span class="sd">    </span>
<span class="sd">    :type spectrogram: dict</span>
<span class="sd">    :param spectrogram: Spectrogram dictionary</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **ret_dict**: dictionary that contains the following keys:</span>
<span class="sd">        *is_incomplete*: True if a keyword is missed</span>
<span class="sd">        *missed_keys*: list of missed keywords</span>
<span class="sd">        *wrong_class*: list of keyworkds which value is of a wrong class</span>
<span class="sd">        *ERROR_stats*: list of errors (strings) detected in the &#39;stats&#39; object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;spec_mat&#39;</span><span class="p">,</span> <span class="s">&#39;stats&#39;</span><span class="p">,</span> <span class="s">&#39;frequency&#39;</span><span class="p">,</span> <span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="s">&#39;unit&#39;</span><span class="p">]</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>

    <span class="n">is_incomplete</span><span class="p">,</span> <span class="n">missed_keys</span><span class="p">,</span> <span class="n">wrong_classes</span> <span class="o">=</span> \
        <span class="n">_check_dict</span><span class="p">(</span><span class="n">spectrogram</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">klass</span><span class="p">))</span>

    <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">spectrogram</span><span class="p">[</span><span class="s">&#39;stats&#39;</span><span class="p">])</span>

    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;is_incomplete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_incomplete</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;missed_keys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_keys</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;wrong_classes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_classes</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">missed_keys</span> <span class="ow">or</span> <span class="n">wrong_classes</span> <span class="ow">or</span> <span class="n">ERROR_stats</span><span class="p">):</span>
        <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;valid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;valid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="n">ret_dict</span>


<span class="k">def</span> <span class="nf">corr_mat_check</span><span class="p">(</span><span class="n">corr_mat_struct</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Correlation matrix dictionary check</span>

<span class="sd">    This function test if the a loaded correlation matrix dictionary</span>
<span class="sd">    contains the requested keywords and if their corresponding value is of the</span>
<span class="sd">    proper class to continue the processing, e.g., to calcule the velocity</span>
<span class="sd">    change.</span>

<span class="sd">    Actually the requested keywords are:</span>
<span class="sd">        &#39;corr_data&#39;</span>
<span class="sd">        &#39;stats&#39;</span>
<span class="sd">        &#39;stats_tr1&#39;</span>
<span class="sd">        &#39;stats_tr2&#39;</span>
<span class="sd">        &#39;time&#39;</span>

<span class="sd">    and their class is, for all of them, :py:class:`numpy.ndarray`.</span>
<span class="sd">    The three &quot;stats&quot; objects are also checked for some &quot;main&quot; errors like</span>
<span class="sd">    the starttime greather then the endtime or a substaintial (greater then 1</span>
<span class="sd">    sample) disagreement between starttime, endtime, sampling_rate and npts.</span>

<span class="sd">    :type corr_mat_struct: dict</span>
<span class="sd">    :param corr_mat_struct: Correlation matrix dictionary</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **ret_dict**: dictionary that contains the following keys:</span>
<span class="sd">        *is_incomplete*: True if a keyword is missed</span>
<span class="sd">        *missed_keys*: list of missed keywords</span>
<span class="sd">        *wrong_class*: list of keyworkds which value is of a wrong class</span>
<span class="sd">        *ERROR_stats*: list of errors (strings) detected in the &#39;stats&#39; object</span>
<span class="sd">        *ERROR_stats_tr1*: list of errors (strings) detected in the</span>
<span class="sd">            &#39;stats_tr1&#39; object</span>
<span class="sd">        *ERROR_stats_tr2**: list of errors (strings) detected in the</span>
<span class="sd">            &#39;stats_tr2&#39; object</span>

<span class="sd">    ... rubric:: Notes</span>

<span class="sd">    If the correlation matrices have been saved to a matlab file and than</span>
<span class="sd">    reloaded, it is supposed that the stats onbjects have been flattened.</span>
<span class="sd">    For instance, this can be achieved doing the reload with the function</span>
<span class="sd">    :py:func:`~miic.core.miic_utils.mat_to_ndarray` setting the flag</span>
<span class="sd">    flatten to True (this is the default value)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;corr_data&#39;</span><span class="p">,</span> <span class="s">&#39;stats&#39;</span><span class="p">,</span> <span class="s">&#39;stats_tr1&#39;</span><span class="p">,</span> <span class="s">&#39;stats_tr2&#39;</span><span class="p">,</span> <span class="s">&#39;time&#39;</span><span class="p">]</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>

    <span class="n">is_incomplete</span><span class="p">,</span> <span class="n">missed_keys</span><span class="p">,</span> <span class="n">wrong_classes</span> <span class="o">=</span> \
        <span class="n">_check_dict</span><span class="p">(</span><span class="n">corr_mat_struct</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">klass</span><span class="p">))</span>

    <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">corr_mat_struct</span><span class="p">[</span><span class="s">&#39;stats&#39;</span><span class="p">])</span>

    <span class="n">ERROR_stats_tr1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats_tr1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats_tr1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats_tr1</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">corr_mat_struct</span><span class="p">[</span><span class="s">&#39;stats_tr1&#39;</span><span class="p">])</span>

    <span class="n">ERROR_stats_tr2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats_tr2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats_tr2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats_tr2</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">corr_mat_struct</span><span class="p">[</span><span class="s">&#39;stats_tr2&#39;</span><span class="p">])</span>

    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;is_incomplete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_incomplete</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;missed_keys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_keys</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;wrong_classes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_classes</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats_tr1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats_tr1</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats_tr2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats_tr2</span>

    <span class="k">return</span> <span class="n">ret_dict</span>


<span class="k">def</span> <span class="nf">dv_check</span><span class="p">(</span><span class="n">dv_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Velocity change dictionary check</span>

<span class="sd">    This function test if a loaded velocity change dictionary</span>
<span class="sd">    contains the requested keywords and if their corresponding value is of the</span>
<span class="sd">    proper class to continue the processing, e.g., to create a DataFrame.</span>

<span class="sd">    Actually the requested keywords -&gt; class pairs are:</span>
<span class="sd">        &#39;corr&#39;            -&gt; :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;value&#39;           -&gt; :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;time&#39;            -&gt; :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;sim_mat&#39;         -&gt; :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;stats&#39;           -&gt; dict</span>
<span class="sd">        &#39;second_axis&#39;     -&gt; :py:class:`numpy.ndarray`</span>
<span class="sd">        &#39;value_type&#39;      -&gt; basestring</span>
<span class="sd">        &#39;method&#39;          -&gt; basestring</span>

<span class="sd">    The &quot;stats&quot; objects is also checked for some &quot;main&quot; errors like</span>
<span class="sd">    the starttime greather then the endtime or a substaintial (greater then 1</span>
<span class="sd">    sample) disagreement between starttime, endtime, sampling_rate and npts.</span>

<span class="sd">    :type dv_dict: dict</span>
<span class="sd">    :param dv_dict: Velocity change dictionary</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **ret_dict**: dictionary that contains the following keys:</span>
<span class="sd">        *is_incomplete*: True if a keyword is missed</span>
<span class="sd">        *missed_keys*: list of missed keywords</span>
<span class="sd">        *wrong_class*: list of keyworkds which value is of a wrong class</span>
<span class="sd">        *ERROR_stats*: list of errors (strings) detected in the &#39;stats&#39; object</span>

<span class="sd">    ... rubric:: Notes</span>

<span class="sd">    If the dv dictionary have been saved to a matlab file and than</span>
<span class="sd">    reloaded, it is supposed that the stats onbjects have been flattened.</span>
<span class="sd">    For instance, this can be achieved doing the reload with the function</span>
<span class="sd">    :py:func:`~miic.core.miic_utils.mat_to_ndarray` setting the flag</span>
<span class="sd">    flatten to True (this is the default value)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;corr&#39;</span><span class="p">,</span> <span class="s">&#39;value&#39;</span><span class="p">,</span> <span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="s">&#39;sim_mat&#39;</span><span class="p">,</span> <span class="s">&#39;stats&#39;</span><span class="p">,</span> \
            <span class="s">&#39;second_axis&#39;</span><span class="p">,</span> <span class="s">&#39;value_type&#39;</span><span class="p">,</span> <span class="s">&#39;method&#39;</span><span class="p">]</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> \
             <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>

    <span class="n">is_incomplete</span><span class="p">,</span> <span class="n">missed_keys</span><span class="p">,</span> <span class="n">wrong_classes</span> <span class="o">=</span> \
        <span class="n">_check_dict</span><span class="p">(</span><span class="n">dv_dict</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">klass</span><span class="p">))</span>

    <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">missed_keys</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;stats&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_classes</span><span class="p">):</span>
        <span class="n">ERROR_stats</span> <span class="o">=</span> <span class="n">_check_stats</span><span class="p">(</span><span class="n">dv_dict</span><span class="p">[</span><span class="s">&#39;stats&#39;</span><span class="p">])</span>

    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;is_incomplete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_incomplete</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;missed_keys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_keys</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;wrong_classes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_classes</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;ERROR_stats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ERROR_stats</span>

    <span class="k">return</span> <span class="n">ret_dict</span>


<span class="k">def</span> <span class="nf">dcs_check</span><span class="p">(</span><span class="n">dcs_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Dv-Corr-Stats dictionary (dcs_dict) check</span>

<span class="sd">    This function test if a dcs dictionary contains the requested</span>
<span class="sd">    keywords and if their corresponding value is of the</span>
<span class="sd">    proper class to continue the processing, e.g., to do the inversion.</span>

<span class="sd">    Actually the requested keywords -&gt; class pairs are:</span>
<span class="sd">        &#39;dvP&#39;             -&gt; :py:class:`pandas.Panel`</span>
<span class="sd">        &#39;corrP&#39;           -&gt; :py:class:`pandas.Panel`</span>
<span class="sd">        &#39;stats&#39;           -&gt; :py:class:`pandas.DataFrame`</span>

<span class="sd">    :type dcs_dict: dict</span>
<span class="sd">    :param dcs_dict: Dv-Corr-Stats dictionary</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **ret_dict**: dictionary that contains the following keys:</span>
<span class="sd">        *is_incomplete*: True if a keyword is missed</span>
<span class="sd">        *missed_keys*: list of missed keywords</span>
<span class="sd">        *wrong_class*: list of keyworkds which value is of a wrong class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;dvP&#39;</span><span class="p">,</span> <span class="s">&#39;corrP&#39;</span><span class="p">,</span> <span class="s">&#39;stats&#39;</span><span class="p">]</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="p">[</span><span class="n">Panel</span><span class="p">,</span> <span class="n">Panel</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">]</span>

    <span class="n">is_incomplete</span><span class="p">,</span> <span class="n">missed_keys</span><span class="p">,</span> <span class="n">wrong_classes</span> <span class="o">=</span> \
        <span class="n">_check_dict</span><span class="p">(</span><span class="n">dcs_dict</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">klass</span><span class="p">))</span>

    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;is_incomplete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_incomplete</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;missed_keys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_keys</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;wrong_classes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_classes</span>

    <span class="k">return</span> <span class="n">ret_dict</span>


<span class="k">def</span> <span class="nf">adv_check</span><span class="p">(</span><span class="n">adv_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Apparent velocity change dictionary (adv_dict) check</span>

<span class="sd">    This function test if a adv dictionary contains the requested</span>
<span class="sd">    keywords and if their corresponding value is of the</span>
<span class="sd">    proper class to continue the processing, e.g., to plot the</span>
<span class="sd">    apparent velocity change on a grid.</span>

<span class="sd">    Actually the requested keywords -&gt; class pairs are:</span>
<span class="sd">        &#39;apparent_dv&#39;     -&gt; :py:class:`pandas.DataFrame`</span>
<span class="sd">        &#39;points_geo_info&#39; -&gt; :py:class:`pandas.DataFrame`</span>
<span class="sd">        &#39;residuals&#39;       -&gt; :py:class:`pandas.DataFrame`</span>

<span class="sd">    :type adv_dict: dict</span>
<span class="sd">    :param adv_dict: Apparent velocity change dictionary</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **ret_dict**: dictionary that contains the following keys:</span>
<span class="sd">        *is_incomplete*: True if a keyword is missed</span>
<span class="sd">        *missed_keys*: list of missed keywords</span>
<span class="sd">        *wrong_class*: list of keyworkds which value is of a wrong class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;apparent_dv&#39;</span><span class="p">,</span> <span class="s">&#39;points_geo_info&#39;</span><span class="p">,</span> <span class="s">&#39;residuals&#39;</span><span class="p">]</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">]</span>

    <span class="n">is_incomplete</span><span class="p">,</span> <span class="n">missed_keys</span><span class="p">,</span> <span class="n">wrong_classes</span> <span class="o">=</span> \
        <span class="n">_check_dict</span><span class="p">(</span><span class="n">adv_dict</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">klass</span><span class="p">))</span>

    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;is_incomplete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_incomplete</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;missed_keys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">missed_keys</span>
    <span class="n">ret_dict</span><span class="p">[</span><span class="s">&#39;wrong_classes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrong_classes</span>

    <span class="k">return</span> <span class="n">ret_dict</span>


<span class="k">def</span> <span class="nf">create_panel</span><span class="p">(</span><span class="n">df_list</span><span class="p">,</span> <span class="n">df_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a Panel given a list of DataFrame and a list of names</span>

<span class="sd">    This function creates a :py:class:`~pandas.Panel` putting together a list</span>
<span class="sd">    of DataFrame contained in the `df_list&#39; argument and assigning to each</span>
<span class="sd">    one of them a name according to the list `df_names`</span>
<span class="sd">    (df_list[i] -&gt; df_names[i]).</span>

<span class="sd">    :type df_list: list of :py:class:`~pandas.DataFrame`</span>
<span class="sd">    :param df_list: List of DataFrames to combine on a single Panel</span>
<span class="sd">    :type df_names: list of strings</span>
<span class="sd">    :param df_names: List of names to assign to the DataFrames</span>

<span class="sd">    :rtype: :py:class:`~pandas.Panel`</span>
<span class="sd">    :return: **dp**: Panel - dp[name] = df name where name=df_names[i]</span>
<span class="sd">        and df = df_list[i]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">df_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;&#39;df_list&#39; must contain pandas DataFrames&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_names</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Each DataFrame must have a unique name&quot;</span><span class="p">)</span>

    <span class="c"># Dictionary that will hold the DataFrame to pass to the Panel constructor</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df_list</span><span class="p">,</span> <span class="n">df_names</span><span class="p">):</span>
        <span class="n">dd</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>

    <span class="n">dp</span> <span class="o">=</span> <span class="n">Panel</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span>


<span class="k">def</span> <span class="nf">dv_dataframe_weight</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">corr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Multiply column-by-column two DataFrame</span>

<span class="sd">    This funciton multiplies column-by-column two</span>
<span class="sd">    :py:class:`~pandas.DataFrame` and returns the obtained DataFrame.</span>
<span class="sd">    One possible application is where one of the two DataFrames represents</span>
<span class="sd">    a weight for the other like what happend when averaging multiple</span>
<span class="sd">    velocity changes for the same stations-pair obtained with different</span>
<span class="sd">    componens.</span>

<span class="sd">    :type dv: :py:class:`~pandas.DataFrame`</span>
<span class="sd">    :param dv: First DataFrame</span>
<span class="sd">    :type corr: :py:class:`~pandas.DataFrame`</span>
<span class="sd">    :param corr: Second DataFrame</span>

<span class="sd">    :rtype: :py:class:`~pandas.DataFrame`</span>
<span class="sd">    :return: **dv_weighted**: dv_weighted[col] = dv[col] * corr[col] for all</span>
<span class="sd">        col in dv</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;dv and corr must be pandas DataFrames&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dv</span><span class="o">.</span><span class="n">columns</span> <span class="o">==</span> <span class="n">corr</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;dv and corr DataFrame do not contain all the same </span><span class="se">\</span>
<span class="s">            stations&quot;</span><span class="p">)</span>

    <span class="n">dv_weighted</span> <span class="o">=</span> <span class="n">dv</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">dv</span><span class="p">:</span>
        <span class="n">cdv</span> <span class="o">=</span> <span class="n">dv</span><span class="p">[</span><span class="n">station</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">station</span><span class="p">]</span>
        <span class="n">dv_weighted</span><span class="p">[</span><span class="n">station</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdv</span> <span class="o">*</span> <span class="n">weight</span>

    <span class="k">return</span> <span class="n">dv_weighted</span>


<span class="k">def</span> <span class="nf">dv_weighted_average</span><span class="p">(</span><span class="n">dv_corr_tupels_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the weighted average of dv/v curves</span>

<span class="sd">    This function does the weighted average of different dv/v curves, for</span>
<span class="sd">    example obtained analyzing different componenets combinations (i.e. ZZ,</span>
<span class="sd">    NN, EE, EZ etc.).</span>
<span class="sd">    Differen curves are weighted according to the their correlation variance</span>
<span class="sd">    as in Weaver et al. GJI 2011 (On the precision of noise correlation</span>
<span class="sd">    interferometry).</span>

<span class="sd">    :type dv_corr_tupels_list: list</span>
<span class="sd">    :param dv_corr_tupels_list: list of dv_corr tuples like [(dv1,corr1),</span>
<span class="sd">    (dv2,corr2),.....,(dvN,corrN)]. Each dv and corr is an object of type</span>
<span class="sd">    :py:class:`~pandas.DataFrame`.</span>

<span class="sd">    :rtype: dict</span>
<span class="sd">    :return: **avg_df_dict**: dictionary that contains the following keys:</span>
<span class="sd">        **avg_dv**: averaged dv/v curves (:py:class:`~pandas.DataFrame`)</span>
<span class="sd">        **avg_corr**: averaged correlation curves</span>
<span class="sd">            (:py:class:`~pandas.DataFrame`)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span> <span class="o">=</span> <span class="n">dv_corr_tupels_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># remove the channel from the combined seed id</span>
    <span class="n">dv</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">corr</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># remove extreme points</span>
    <span class="n">dv</span><span class="p">[</span><span class="n">corr</span> <span class="o">&gt;</span> <span class="mf">0.999</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">corr</span><span class="p">[</span><span class="n">corr</span> <span class="o">&gt;</span> <span class="mf">0.999</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">corr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">res_dv</span> <span class="o">=</span> <span class="n">dv</span> <span class="o">*</span> <span class="n">weight</span>
    <span class="n">res_corr</span> <span class="o">=</span> <span class="n">corr</span> <span class="o">*</span> <span class="n">weight</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">corr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dv_corr_tupels_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="c"># remove the channel from the combined seed id</span>
        <span class="n">dv</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                  <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">corr</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># remove extreme points</span>
        <span class="n">dv</span><span class="p">[</span><span class="n">corr</span> <span class="o">&gt;</span> <span class="mf">0.999</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">corr</span><span class="p">[</span><span class="n">corr</span> <span class="o">&gt;</span> <span class="mf">0.999</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c"># Calculate the variance</span>
        <span class="n">cw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">corr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># increment the pseudo-correlation</span>
        <span class="n">res_corr</span> <span class="o">+=</span> <span class="n">corr</span> <span class="o">*</span> <span class="n">cw</span>

        <span class="c"># apply the weight to the dv</span>
        <span class="n">res_dv</span> <span class="o">+=</span> <span class="n">dv</span> <span class="o">*</span> <span class="n">cw</span>

        <span class="c"># increment the total weight</span>
        <span class="n">weight</span> <span class="o">+=</span> <span class="n">cw</span>

    <span class="c"># normalize the resulting dataframes</span>
    <span class="n">res_dv</span> <span class="o">=</span> <span class="n">res_dv</span> <span class="o">/</span> <span class="n">weight</span>
    <span class="n">res_corr</span> <span class="o">=</span> <span class="n">res_corr</span> <span class="o">/</span> <span class="n">weight</span>

    <span class="c"># add a fake channel to creeate a data structure consistent with the rest</span>
    <span class="c"># of the library</span>
    <span class="c"># TODO: create the list of combined channels and put it here instead of</span>
    <span class="c"># the fake channels pair.</span>
    <span class="n">res_dv</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.XX-XX&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">res_corr</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&#39;.XX-XX&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">avg_df_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;avg_dv&#39;</span><span class="p">:</span> <span class="n">res_dv</span><span class="p">,</span>
                   <span class="s">&#39;avg_corr&#39;</span><span class="p">:</span> <span class="n">res_corr</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">avg_df_dict</span>


<span class="k">def</span> <span class="nf">interp_gaps</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">inds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Fill missed values through linear interpolation</span>

<span class="sd">    This function fills missed values through linear interpolation if the gap</span>
<span class="sd">    is shorter than a maximum lenght.</span>

<span class="sd">    :type x: 1D :class:`~numpy.ndarray`</span>
<span class="sd">    :param x: Array where to fill missed values</span>
<span class="sd">    :type max_len: int</span>
<span class="sd">    :param max_len: maximun length of a filled gap</span>
<span class="sd">    :type inds: 1D :class:`~numpy.ndarray` (optional)</span>
<span class="sd">    :param inds: index where to interpolate (must be increasing). If None it</span>
<span class="sd">        default to np.arange(x.shape[0])</span>

<span class="sd">    :rtype: 1D :class:`~numpy.ndarray`</span>
<span class="sd">    :return:**x**:Array with missed values filled when suitable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c"># Check if there are missed values</span>
    <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">inds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="o">-</span><span class="n">invalid</span>

    <span class="n">firstIndex</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="n">lastIndex</span> <span class="o">=</span> <span class="n">valid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">valid</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span><span class="p">[</span><span class="n">firstIndex</span><span class="p">:</span><span class="n">lastIndex</span><span class="p">]</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="n">invalid</span><span class="p">[</span><span class="n">firstIndex</span><span class="p">:</span><span class="n">lastIndex</span><span class="p">]</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">firstIndex</span><span class="p">:</span><span class="n">lastIndex</span><span class="p">]</span>

    <span class="c"># Find missed values intervals and their length</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">valid</span><span class="p">))[</span><span class="mi">0</span><span class="p">][::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">valid</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">length</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">max_len</span><span class="p">)</span>

    <span class="c"># If all the intervals are longer then max_len return</span>
    <span class="c"># the original vector</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="c"># Do the linear interpolation</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
                                 <span class="nb">zip</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="n">ms</span><span class="p">],</span> <span class="n">stop</span><span class="p">[</span><span class="n">ms</span><span class="p">])))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int&#39;</span><span class="p">)</span>

    <span class="n">x</span><span class="p">[</span><span class="n">firstIndex</span><span class="p">:</span><span class="n">lastIndex</span><span class="p">][</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">invalid</span><span class="p">],</span>
            <span class="n">inds</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span>
            <span class="n">x</span><span class="p">[</span><span class="n">firstIndex</span><span class="p">:</span><span class="n">lastIndex</span><span class="p">][</span><span class="n">valid</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">create_date_obj</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a datetime object &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_create_date_obj_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">2011</span><span class="p">)</span>
        <span class="n">month</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">day</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;year&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;month&#39;</span><span class="p">),</span>
                          <span class="n">Item</span><span class="p">(</span><span class="s">&#39;day&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">load_pickled_Series_DataFrame_Panel</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Load a pickled DataFrame (ref. pandas prj) &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">npyio</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_load_pickled_Series_DataFrame_Panel_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">File</span><span class="p">()</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;filename&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">get_values_DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get the values out of DataFrame (ref. pandas prj) &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">&#39;values&#39;</span><span class="p">:</span> <span class="n">values</span><span class="p">,</span> <span class="s">&#39;index&#39;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="s">&#39;columns&#39;</span><span class="p">:</span> <span class="n">columns</span><span class="p">}</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_get_values_DataFrame_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">get_valid_traces</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retun only valid traces of a stream.</span>

<span class="sd">    Remove traces that are 100% masked from a stream. This happens when </span>
<span class="sd">    a masked trace is trimmed within a gap. The function works in place.</span>

<span class="sd">    :type st: obspy.Stream</span>
<span class="sd">    :param st: stream to work on</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="n">Stream</span><span class="p">,</span> <span class="s">&quot;Input st is not an obspy.Stream.&quot;</span>

    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">st</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
    <span class="k">return</span>


<div class="viewcode-block" id="import_function_by_name"><a class="viewcode-back" href="../../../modules/autogen/miic.core.miic_utils.import_function_by_name.html#miic.core.miic_utils.import_function_by_name">[docs]</a><span class="k">def</span> <span class="nf">import_function_by_name</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Import a function of a given name.</span>

<span class="sd">    Import a function given its name as string and return it.</span>
<span class="sd">    Example for func_name: obspy.core.read</span>

<span class="sd">    :type func_name: string</span>
<span class="sd">    :param func_name: name of function to import</span>
<span class="sd">    :rtype: object</span>
<span class="sd">    :return: function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">,</span> <span class="s">&quot;func is not a string&quot;</span>
    <span class="k">assert</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">func</span><span class="p">,</span> <span class="s">&quot;func must name the function including its module: </span><span class="si">%s</span><span class="s">&quot;</span>\
                         <span class="o">%</span> <span class="n">func</span>
    <span class="n">modname</span> <span class="o">=</span> <span class="n">func</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">func</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">funcname</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">func</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">):]</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">modname</span><span class="p">)</span>
    <span class="n">function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">funcname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">function</span>

</div>
<span class="k">def</span> <span class="nf">find_stations_name</span><span class="p">(</span><span class="n">comb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract the ordered list of stations from a set of traces id &quot;&quot;&quot;</span>

    <span class="n">stations_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
        <span class="n">networks</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">one</span><span class="p">,</span> <span class="n">two</span> <span class="o">=</span> <span class="n">stations</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">one</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stations_list</span><span class="p">:</span>
            <span class="n">stations_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">two</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stations_list</span><span class="p">:</span>
            <span class="n">stations_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">two</span><span class="p">)</span>
    <span class="n">stations_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stations_list</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">from_comb_to_stations_list</span><span class="p">(</span><span class="n">comb</span><span class="p">,</span> <span class="n">full_stations_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extract the list of stations involved in a series of combinations &quot;&quot;&quot;</span>

    <span class="n">stat_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
        <span class="n">networks</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">one</span><span class="p">,</span> <span class="n">two</span> <span class="o">=</span> <span class="n">stations</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">full_stations_list</span> <span class="o">==</span> <span class="n">one</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">full_stations_list</span> <span class="o">==</span> <span class="n">two</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stat_list</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">stat_list</span>


<span class="k">def</span> <span class="nf">from_str_comb_to_list</span><span class="p">(</span><span class="n">str_comb</span><span class="p">,</span> <span class="n">full_stations_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; From a list of str combinations to a list of tuples</span>

<span class="sd">    This function transform a list of combinations in the form</span>
<span class="sd">    [&#39;UV01-UV12&#39;,&#39;UV03-UV21&#39;,...] in a list of tuples</span>
<span class="sd">    like [(1,12),(3,21),...]. It works for combinations where</span>
<span class="sd">    the station name is just two letters.</span>

<span class="sd">    .. rubric:: Note</span>

<span class="sd">    Remember that indexing in python starts from 0 rather then the</span>
<span class="sd">    general form of the str combinations that starts form station 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">comb_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">str_comb</span><span class="p">:</span>
        <span class="n">networks</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">one</span><span class="p">,</span> <span class="n">two</span> <span class="o">=</span> <span class="n">stations</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">full_stations_list</span> <span class="o">==</span> <span class="n">one</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">full_stations_list</span> <span class="o">==</span> <span class="n">two</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">comb_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">comb_list</span>


<span class="k">def</span> <span class="nf">extract_stations_info</span><span class="p">(</span><span class="n">stats_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extrace stations geographical infromation from stats DataFrame</span>

<span class="sd">    This function extraxt the geographycal information about all stations</span>
<span class="sd">    reported in the stats DataFrame as it is created by the funciton</span>
<span class="sd">    :py:func:`~miic.core.macro.from_single_pattern_to_panel`.</span>

<span class="sd">    :type stats_df: :py:class:`~pandas.DataFrame`</span>
<span class="sd">    :param stats_df: Stats DataFrame</span>

<span class="sd">    :rtype: :py:class:`~pandas.DataFrame`</span>
<span class="sd">    :return:**stations_info**: Pandas DataFrame which index is the ordered</span>
<span class="sd">        list of stations and the columns are: &#39;easting&#39;, &#39;northing&#39; and</span>
<span class="sd">        &#39;elevation&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stats_df</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;stats_df and corr must be pandas DataFrames&quot;</span><span class="p">)</span>

    <span class="n">stations_name</span> <span class="o">=</span> <span class="n">find_stations_name</span><span class="p">(</span><span class="n">stats_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="n">stations_info</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">stations_name</span><span class="p">,</span>
                              <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;easting&#39;</span><span class="p">,</span> <span class="s">&#39;northing&#39;</span><span class="p">,</span> <span class="s">&#39;elevation&#39;</span><span class="p">])</span>
    <span class="n">parsed</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
        <span class="c"># print label</span>
        <span class="n">networks</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">locations</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">one</span><span class="p">,</span> <span class="n">two</span> <span class="o">=</span> <span class="n">stations</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">one</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parsed</span><span class="p">:</span>
            <span class="n">stations_info</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">one</span><span class="p">][</span><span class="s">&#39;easting&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s">&#39;stlo&#39;</span><span class="p">]</span>
            <span class="n">stations_info</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">one</span><span class="p">][</span><span class="s">&#39;northing&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s">&#39;stla&#39;</span><span class="p">]</span>
            <span class="n">stations_info</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">one</span><span class="p">][</span><span class="s">&#39;elevation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s">&#39;stel&#39;</span><span class="p">]</span>
            <span class="n">parsed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">two</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parsed</span><span class="p">:</span>
            <span class="n">stations_info</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">two</span><span class="p">][</span><span class="s">&#39;easting&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s">&#39;evlo&#39;</span><span class="p">]</span>
            <span class="n">stations_info</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">two</span><span class="p">][</span><span class="s">&#39;northing&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s">&#39;evla&#39;</span><span class="p">]</span>
            <span class="n">stations_info</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">two</span><span class="p">][</span><span class="s">&#39;elevation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s">&#39;evel&#39;</span><span class="p">]</span>
            <span class="n">parsed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">two</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stations_info</span>


<span class="k">def</span> <span class="nf">from_single_pattern_to_panel</span><span class="p">(</span><span class="n">load_dir</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s">&#39;./save&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> \
                                 <span class="n">suffix</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">old_style</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create :class:`pandas.Panel` object recombining all corr and dv curves.</span>

<span class="sd">    This function creates two :py:class:`pandas.Panel` object recombining</span>
<span class="sd">    respectively all correlation `curve` and `dv/v` curve created for</span>
<span class="sd">    a specific dataset and one :py:class:`pandas.DataFrame` containing all</span>
<span class="sd">    the metainformation in each `stats` object associated with one stations</span>
<span class="sd">    pair.</span>
<span class="sd">    Source timing, correlation value and velocity change are all stored in a</span>
<span class="sd">    matlab file with the name of this form (look at</span>
<span class="sd">    :class:`~miic.core.miic_utils.convert_to_matlab` for a detailed</span>
<span class="sd">    description):</span>
<span class="sd">        vchange_full_&lt;pattern&gt;_&lt;suffix&gt;_.mat</span>

<span class="sd">    Suffix is equal to ``&quot;_%sHz&quot; % fs`` when ``old_style==True``.</span>

<span class="sd">    Patterns that are processed without errors are logged in a file</span>
<span class="sd">    ``success_patterns.npy`` saved in the `save_dir` directory.</span>

<span class="sd">    :type load_dir: string</span>
<span class="sd">    :param load_dir: Where the dv/v and corr curves are stored</span>
<span class="sd">    :type save_dir: string</span>
<span class="sd">    :param save_dir: Where the two Panels will be saved</span>
<span class="sd">    :type fs: float</span>
<span class="sd">    :param fs: Pseudo Sampling frequency for the corr curve</span>
<span class="sd">    :type suffix: string</span>
<span class="sd">    :param suffix: Optional suffix for the filename to look for (it must be the</span>
<span class="sd">        same as used with the :class:`~miic.core.macro.vchange_estimate`</span>
<span class="sd">        function through with the corr ad dv/v curves were created)</span>
<span class="sd">    :type old_style: bool</span>
<span class="sd">    :param old_style: If true, the suffic is generated using the `fs`</span>
<span class="sd">        ( &quot;_&lt;fs&gt;Hz&quot;) instead of being passed as a parameter)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">save_dir</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;`save_dir` doesn&#39;t exist ..... creating&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">save_dir</span><span class="p">)</span>

    <span class="n">base_patterns</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">old_style</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">Hz&quot;</span> <span class="o">%</span> <span class="n">fs</span>

    <span class="n">successfull</span> <span class="o">=</span> <span class="n">find_comb</span><span class="p">(</span><span class="n">load_dir</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>

    <span class="n">stats_df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;evel&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;endtime&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;dist&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;network&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;channel&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;stlo&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;baz&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;stel&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;evla&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;npts&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;station&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;location&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;starttime&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;sampling_rate&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;stla&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;az&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;evlo&#39;</span><span class="p">])</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">successfull</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">suffix</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">vchange_fname</span> <span class="o">=</span> <span class="s">&#39;vchange_full_&#39;</span> <span class="o">+</span> <span class="n">pattern</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">suffix</span> <span class="o">+</span> <span class="s">&#39;.mat&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vchange_fname</span> <span class="o">=</span> <span class="s">&#39;vchange_full_&#39;</span> <span class="o">+</span> <span class="n">pattern</span> <span class="o">+</span> <span class="s">&#39;.mat&#39;</span>

        <span class="n">vchange_vars</span> <span class="o">=</span> <span class="n">mat_to_ndarray</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">load_dir</span><span class="p">,</span> <span class="n">vchange_fname</span><span class="p">))</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">convert_time</span><span class="p">(</span><span class="n">vchange_vars</span><span class="p">[</span><span class="s">&#39;time&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Time format error: skip pattern </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">pattern</span>
            <span class="k">continue</span>

        <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">vchange_vars</span><span class="p">[</span><span class="s">&#39;corr&#39;</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">vchange_vars</span><span class="p">[</span><span class="s">&#39;value&#39;</span><span class="p">])</span>  <span class="c"># Current key</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c"># Try to address also the old style dv dict</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">vchange_vars</span><span class="p">[</span><span class="s">&#39;dv&#39;</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">vchange_vars</span><span class="p">[</span><span class="s">&#39;dt&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span>

        <span class="k">if</span> <span class="s">&#39;stats&#39;</span> <span class="ow">in</span> <span class="n">vchange_vars</span><span class="p">:</span>
            <span class="n">stats</span> <span class="o">=</span> <span class="n">flatten_recarray</span><span class="p">(</span><span class="n">vchange_vars</span><span class="p">[</span><span class="s">&#39;stats&#39;</span><span class="p">])</span>

            <span class="c"># It is necessary to be then able to separate the different</span>
            <span class="c"># stations name from the columns name of the created dataframe</span>
            <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;network&#39;</span><span class="p">,</span> <span class="s">&#39;station&#39;</span><span class="p">,</span> <span class="s">&#39;location&#39;</span><span class="p">,</span> <span class="s">&#39;channel&#39;</span><span class="p">]</span>
            <span class="n">tr_id</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> \
                              <span class="n">keywords</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">basestring</span><span class="p">)])</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">tr_id</span>

            <span class="n">cdf</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">pattern</span><span class="p">])</span>
            <span class="n">stats_df</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdf</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># Adapt dv and corr in case they are single curves</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dv</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="n">dv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">pqr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">win_lab</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dv</span><span class="p">)):</span>
                <span class="n">lab</span> <span class="o">=</span> <span class="s">&#39;win-</span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">k</span>
                <span class="n">win_lab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                <span class="n">xyz</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">pqr</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dv</span><span class="p">)):</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">corr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
            <span class="c"># ss = Series(dv[j] - 1, index=time)</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">dv</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">win_lab</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">pattern</span><span class="p">:</span> <span class="n">ss</span><span class="p">})</span>
            <span class="n">pqr</span><span class="p">[</span><span class="n">win_lab</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">pattern</span><span class="p">:</span> <span class="n">cc</span><span class="p">})</span>

        <span class="n">base_patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

    <span class="n">dv</span> <span class="o">=</span> <span class="n">Panel</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">Panel</span><span class="p">(</span><span class="n">pqr</span><span class="p">)</span>

    <span class="n">dcs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;dvP&#39;</span><span class="p">:</span> <span class="n">dv</span><span class="p">,</span>
                <span class="s">&#39;corrP&#39;</span><span class="p">:</span> <span class="n">corr</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dcs_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;stats&#39;</span><span class="p">:</span> <span class="n">stats_df</span><span class="p">})</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s">&#39;dcs_dict.pickle&#39;</span><span class="p">),</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_out</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Pickler</span><span class="p">(</span><span class="n">f_out</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dcs_dict</span><span class="p">)</span>

    <span class="c">#     dv.save(os.path.join(save_dir, &#39;dv.pickle&#39;))</span>
    <span class="c">#     corr.save(os.path.join(save_dir, &#39;corr.pickle&#39;))</span>
    <span class="c">#     if len(stats_df) &gt; 0:</span>
    <span class="c">#         stats_df.save(os.path.join(save_dir, &#39;stats.pickle&#39;))</span>

    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s">&#39;success_patterns.npy&#39;</span><span class="p">),</span> \
        <span class="n">base_patterns</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dcs_dict</span>


<span class="k">if</span> <span class="n">BC_UI</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">_from_single_pattern_to_panel_view</span><span class="p">(</span><span class="n">HasTraits</span><span class="p">):</span>
        <span class="n">load_dir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">()</span>
        <span class="n">save_dir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">()</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
        <span class="n">old_style</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
        
        <span class="n">trait_view</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">VGroup</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="s">&#39;load_dir&#39;</span><span class="p">),</span>
                                 <span class="n">Item</span><span class="p">(</span><span class="s">&#39;save_dir&#39;</span><span class="p">),</span>
                                 <span class="n">Item</span><span class="p">(</span><span class="s">&#39;fs&#39;</span><span class="p">,</span>
                                      <span class="n">enabled_when</span><span class="o">=</span><span class="s">&#39;old_style&#39;</span><span class="p">),</span>
                                 <span class="n">Item</span><span class="p">(</span><span class="s">&#39;old_style&#39;</span><span class="p">),</span>
                                 <span class="n">Item</span><span class="p">(</span><span class="s">&#39;suffix&#39;</span><span class="p">,</span>
                                      <span class="n">label</span><span class="o">=</span><span class="s">&#39;filename suffix&#39;</span><span class="p">,</span>
                                      <span class="n">enabled_when</span><span class="o">=</span><span class="s">&#39;not old_style&#39;</span><span class="p">)</span>
                                 <span class="p">)</span>
                          <span class="p">)</span>
<span class="c">##############################################################################</span>
<span class="c"># Test function                                                              #</span>
<span class="c">##############################################################################</span>


<span class="k">def</span> <span class="nf">trimmed_std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">percentile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Trimmed standard deviation.&quot;&quot;&quot;</span>
    <span class="c"># data = np.array(data)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">percentile</span> <span class="o">=</span> <span class="n">percentile</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">low</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">percentile</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">high</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">percentile</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ref_sine</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reference sine waveform.&quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">print_input</span><span class="p">(</span><span class="n">input_str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Print its input.&quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="n">input_str</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">print_tuples</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print tuples.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;(</span><span class="si">%(key)s</span><span class="s">,</span><span class="si">%(value)s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;key&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;value&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
    <span class="k">return</span>


<span class="k">def</span> <span class="nf">print_tuple</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print a tuple.&quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&quot;(</span><span class="si">%(key)s</span><span class="s">,</span><span class="si">%(value)s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;key&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;value&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
    <span class="k">return</span>

<span class="c"># EOF</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MIIC 1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, Eraldo Pomponi.
      Last updated on 2017-11-15T10:15:30.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>